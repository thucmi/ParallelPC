{
    "contents" : "#########################################################################################\n### Author: Thuc Duy Le, Tao Hoang and Shu Hu\n### Date: 26th March 2015\n### Please cite the following paper when using the code\n### Paper: A fast PC algorithm for high dimensional causal discovery with multi-core PCs\n#########################################################################################\n#install.packages(\"bnlearn\")\n#source(\"http://cran.rstudio.com/src/contrib/bnlearn_3.8.tar.gz\")\n#install.packages(\"bnlearn\")\n#source(\"http://bioconductor.org/biocLite.R\")\n#biocLite(\"Rgraphviz\")\nlibrary(bnlearn)\nlibrary(pcalg)\nlibrary(parallel)\nlibrary(Rgraphviz)\n\nif(getRversion() >= \"2.15.1\")  utils::globalVariables(c(\"gaussCItest\",\"idaFast\",\"detectCores\",\"makeCluster\",\"clusterEvalQ\",\"stopCluster\",\"pc.cons.intern\",\"pdsep\",\"udag2pag\",\"udag2pdag\",\"udag2pdagSpecial\",\"udag2pdagRelaxed\",\"rfci.vStruc\",\"udag2apag\",\"getNextSet\",\"clusterApply\",\"clusterSplit\",\"mclapply\",\"getNextSet\",\"find.unsh.triple\"))\n#' Estimate (Initial) Skeleton of a DAG using the PC_stable Algorithm\n#' \n#' @description \n#' Estimate the skeleton of a DAG without latent and selection variables using the PC_stable Algorithm or estimate an initial skeleton of a DAG with arbitrarily many latent and selection variables using the FCI_stable and the RFCI_stable algorithms.\n#' \n#' If used in the PC_stable algorithm, it estimates the order-independent \"PC_stable\" (\"stable\") or original PC (\"original\") \"skeleton\" of a directed acyclic graph (DAG) from observational data.\n#' \n#' When used in the FCI_stable and RFCI_stable algorithms, this function estimates only an initial order-independent (or PC original) \"skeleton\". Because of the presence of latent and selection variables, to find the final skeleton those algorithms need to perform additional tests later on and consequently some edges can be further deleted.\n#' @param suffStat Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat) and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha significance level (number in (0,1) for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param method Character string specifying method; the default, \"stable\" provides an order-independent skeleton, see 'Details' below.\n#' @param m.max Maximal size of the conditioning sets that are considered in the conditional independence tests.\n#' @param fixedGaps logical symmetric matrix of dimension p*p. If entry [i,j] is true, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges a logical symmetric matrix of dimension p*p. If entry [i,j] is true, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete logical needed for the case indepTest(*) returns NA. If it is true, the corresponding edge is deleted, otherwise not.\n#' @param verbose if TRUE, detailed output is provided.\n#' @return An object of class \"pcAlgo\" (see pcAlgo) containing an estimate of the skeleton of the underlying DAG, the conditioning sets (sepset) that led to edge removals and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using skeleton_stable\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' skeleton_stable(suffStat, indepTest=gaussCItest, p=p, method=\"stable\", alpha=0.01)\n#' @export\nskeleton_stable <- function(suffStat, indepTest, alpha, labels, p,\n                            method = c(\"stable\", \"original\", \"stable.fast\"), m.max = Inf,\n                            fixedGaps = NULL, fixedEdges = NULL,\n                            NAdelete = TRUE, verbose = FALSE)\n{ \n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  method <- match.arg(method)\n  ## C++ version still has problems under Windows; will have to check why\n  #  if (method == \"stable.fast\" && .Platform$OS.type == \"windows\") {\n  #    method <- \"stable\"\n  #    warning(\"Method 'stable.fast' is not available under Windows; using 'stable' instead.\")\n  #  }\n  \n  ## G := !fixedGaps, i.e. G[i,j] is true  iff  i--j  will be investigated\n  if (is.null(fixedGaps)) {\n    G <- matrix(TRUE, nrow = p, ncol = p)\n    diag(G) <- FALSE\n  }\n  else if (!identical(dim(fixedGaps), c(p, p)))\n    stop(\"Dimensions of the dataset and fixedGaps do not agree.\")\n  else if (!identical(fixedGaps, t(fixedGaps)) )\n    stop(\"fixedGaps must be symmetric\")\n  else\n    G <- !fixedGaps\n  \n  if (any(is.null(fixedEdges))) { ## MM: could be sparse\n    fixedEdges <- matrix(rep(FALSE, p * p), nrow = p, ncol = p)\n  }\n  else if (!identical(dim(fixedEdges), c(p, p)))\n    stop(\"Dimensions of the dataset and fixedEdges do not agree.\")\n  else if (fixedEdges != t(fixedEdges))\n    stop(\"fixedEdges must be symmetric\")\n  \n  start_total <- proc.time()\n  \n  if (method == \"stable.fast\") {\n    ## Do calculation in C++...\n    if (identical(indepTest, gaussCItest))\n      indepTestName <- \"gauss\"\n    else\n      indepTestName <- \"rfun\"\n    options <- list(\n      verbose = as.integer(verbose), \n      m.max = as.integer(ifelse(is.infinite(m.max), p, m.max)),\n      NAdelete = NAdelete)\n    res <- .Call(\"estimateSkeleton\", G, suffStat, indepTestName, indepTest, alpha, fixedEdges, options, PACKAGE = \"ParallelPC\");\n    G <- res$amat\n    # sepset <- res$sepset\n    sepset <- lapply(seq_p, function(i) c(\n      lapply(res$sepset[[i]], function(v) if(identical(v, as.integer(-1))) NULL else v),\n      vector(\"list\", p - length(res$sepset[[i]])))) # TODO change convention: make sepset triangular\n    pMax <- res$pMax\n    n.edgetests <- res$n.edgetests\n    ord <- length(n.edgetests) - 1\n  }\n  else {\n    ## Original R version\n    \n    pval <- NULL\n    sepset <- lapply(seq_p, function(.) vector(\"list\",p))# a list of lists [p x p]\n    ## save maximal p value\n    pMax <- matrix(-Inf, nrow = p, ncol = p)\n    diag(pMax) <- 1\n    done <- FALSE\n    ord <- 0\n    n.edgetests <- numeric(1)# final length = max { ord}\n    while (!done && any(G) && ord <= m.max) {\n      n.edgetests[ord1 <- ord+1L] <- 0\n      done <- TRUE\n      ind <- which(G, arr.ind = TRUE)\n      ## For comparison with C++ sort according to first row\n      ind <- ind[order(ind[, 1]), ]\n      remainingEdgeTests <- nrow(ind)\n      if (verbose)\n        cat(\"Order=\", ord, \"; remaining edges:\", remainingEdgeTests,\"\\n\",sep=\"\")\n      if(method == \"stable\") {\n        ## Order-independent version: Compute the adjacency sets for any vertex\n        ## Then don't update when edges are deleted\n        G.l <- split(G, gl(p,p))\n      }\n      for (i in 1:remainingEdgeTests) {\n        if (verbose && i%%100 == 0) cat(\"|i=\", i, \"|iMax=\", nrow(ind), \"\\n\")\n        x <- ind[i, 1]\n        y <- ind[i, 2]\n        if (G[y, x] && !fixedEdges[y, x]) {\n          nbrsBool <- if(method == \"stable\") G.l[[x]] else G[,x]\n          nbrsBool[y] <- FALSE\n          nbrs <- seq_p[nbrsBool]\n          length_nbrs <- length(nbrs)\n          if (length_nbrs >= ord) {\n            if (length_nbrs > ord)\n              done <- FALSE\n            S <- seq_len(ord)\n            repeat { ## condition w.r.to all  nbrs[S] of size 'ord'\n              n.edgetests[ord1] <- n.edgetests[ord1] + 1\n              pval <- indepTest(x, y, nbrs[S], suffStat)\n              if (verbose)\n                cat(\"x=\", x, \" y=\", y, \" S=\", nbrs[S], \": pval =\", pval, \"\\n\")\n              if(is.na(pval))\n                pval <- as.numeric(NAdelete) ## = if(NAdelete) 1 else 0\n              if (pMax[x, y] < pval)\n                pMax[x, y] <- pval\n              if(pval >= alpha) { # independent\n                G[x, y] <- G[y, x] <- FALSE\n                sepset[[x]][[y]] <- nbrs[S]\n                break\n              }\n              else {\n                nextSet <- getNextSet(length_nbrs, ord, S)\n                if (nextSet$wasLast)\n                  break\n                S <- nextSet$nextSet\n              }\n            } ## repeat\n          }\n        }\n      }# for( i )\n      ord <- ord + 1\n    } ## while()\n    for (i in 1:(p - 1)) {\n      for (j in 2:p)\n        pMax[i, j] <- pMax[j, i] <- max(pMax[i, j], pMax[j,i])\n    }\n  }\n  \n  total_t = proc.time()-start_total\n  \n  # write results\n  cat('n=', suffStat[[2]], ',p=', p, '\\n', sep=\"\")\n  cat('Num CI Tests=', n.edgetests, ',Total CI Tests=', sum(unlist(n.edgetests)), ',Total Time=', total_t[3], '\\n', sep=\" \")\n  \n  ## transform matrix to graph object :\n  Gobject <-\n    if (sum(G) == 0) {\n      new(\"graphNEL\", nodes = labels)\n    } else {\n      colnames(G) <- rownames(G) <- labels\n      as(G,\"graphNEL\")\n    }\n  \n  ## final object\n  new(\"pcAlgo\", graph = Gobject, call = cl, n = integer(0),\n      max.ord = as.integer(ord - 1), n.edgetests = n.edgetests,\n      sepset = sepset, pMax = pMax, zMin = matrix(NA, 1, 1))\n  \n}## end{ skeleton }\n\n#### Parallelized skeleton estimation ####\n#' Estimate (Initial) Skeleton of a DAG fast using the PC_parallel Algorithm\n#' \n#' @description \n#' Estimate the skeleton of a DAG without latent and selection variables using the PC Algorithm or estimate an initial skeleton of a DAG with arbitrarily many latent and selection variables using the FCI and the RFCI algorithms.\n#' \n#' If used in the PC algorithm, it estimates the \"PC-parallel\" (\"parallel\") \"skeleton\" of a directed acyclic graph (DAG) from observational data.\n#' \n#' When used in the FCI_parallel and RFCI_parallel algorithms, this function estimates only an initial PC parallel \"skeleton\". Because of the presence of latent and selection variables, to find the final skeleton those algorithms need to perform additional tests later on and consequently some edges can be further deleted.\n#' @param suffStat Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat) and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha significance level (number in (0; 1) for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param method Character string specifying method; the default, \"parallel\" provides an efficient skeleton, see skeleton_parallel.\n#' @param mem.efficient Uses less amount of memory at any time point while running the algorithm\n#' @param workers Creates a set of copies of R running in parallel and communicating over sockets.\n#' @param num_workers Choose numbers of cores CPU as numbers of workers to run the algorithm\n#' @param m.max Maximal size of the conditioning sets that are considered in the conditional independence tests.\n#' @param fixedGaps A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete  logical needed for the case indepTest(*) returns NA. If it is true, the corresponding edge is deleted, otherwise not.\n#' @param verbose if TRUE, detailed output is provided.\n#' @return An object of class \"pcAlgo\" (see pcAlgo) containing an estimate of the skeleton of the underlying DAG, the conditioning sets (sepset) that led to edge removals and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using skeleton_parallel without mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' skeleton_parallel(suffStat,indepTest=gaussCItest,p=p,method=\"parallel\",alpha=0.01,num_workers=2)\n#'\n#' ##########################################\n#' ## Using skeleton_parallel with mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' skeleton_parallel(suffStat,indepTest=gaussCItest,p=p,method=\"parallel\",\n#' alpha=0.01,num_workers=2,mem.efficient=TRUE)\n#' @export\nskeleton_parallel <- function(suffStat, indepTest, alpha, labels, p,\n                              method = c(\"parallel\"),  mem.efficient=FALSE, workers, num_workers,\n                              m.max = Inf, fixedGaps = NULL, fixedEdges = NULL,\n                              NAdelete = TRUE, verbose = FALSE)\n{\n  \n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  method <- match.arg(method)\n  \n  ## G := !fixedGaps, i.e. G[i,j] is true  iff  i--j  will be investigated\n  if (is.null(fixedGaps)) {\n    G <- matrix(TRUE, nrow = p, ncol = p)\n    diag(G) <- FALSE\n  } else if (!identical(dim(fixedGaps), c(p, p)))\n    stop(\"Dimensions of the dataset and fixedGaps do not agree.\")\n  else if (!identical(fixedGaps, t(fixedGaps)) )\n    stop(\"fixedGaps must be symmetric\")\n  else\n    G <- !fixedGaps\n  \n  if (any(is.null(fixedEdges))) { ## MM: could be sparse\n    fixedEdges <- matrix(rep(FALSE, p * p), nrow = p, ncol = p)\n  } else if (!identical(dim(fixedEdges), c(p, p)))\n    stop(\"Dimensions of the dataset and fixedEdges do not agree.\")\n  else if (fixedEdges != t(fixedEdges))\n    stop(\"fixedEdges must be symmetric\")\n  \n  pval <- NULL\n  sepset <- lapply(seq_p, function(.) vector(\"list\",p))# a list of lists [p x p]\n  ## save maximal p value\n  pMax <- matrix(-Inf, nrow = p, ncol = p)\n  diag(pMax) <- 1\n  done <- FALSE\n  ord <- 0\n  n.edgetests <- numeric(1)# final length = max { ord}\n  \n  # edge test function, conditioning on x's neighbours\n  edge_test_xy <- function(x, y) {\n    G_xy <- TRUE\n    num_tests_xy <- 0\n    pMax_xy <- pMax[x, y]\n    sepset_xy <- NULL\n    done_xy <- TRUE\n    if (G_xy && !fixedEdges[y, x]) {\n      nbrsBool <- G.l[[x]]\n      nbrsBool[y] <- FALSE\n      nbrs <- seq_p[nbrsBool]\n      #rm(nbrsBool)\n      length_nbrs <- length(nbrs)\n      if (length_nbrs >= ord) {\n        if (length_nbrs > ord) done_xy <- FALSE\n        S <- seq_len(ord)\n        repeat { ## condition w.r.to all  nbrs[S] of size 'ord'\n          num_tests_xy <- num_tests_xy + 1\n          pval <- indepTest(x, y, nbrs[S], suffStat)\n          if(is.na(pval)) pval <- as.numeric(NAdelete) ## = if(NAdelete) 1 else 0\n          if (pMax_xy < pval) pMax_xy <- pval\n          if(pval >= alpha) { # independent\n            G_xy <- FALSE\n            sepset_xy <- nbrs[S]\n            break\n          } else {\n            nextSet <- getNextSet(length_nbrs, ord, S)\n            if (nextSet$wasLast)\n              break\n            S <- nextSet$nextSet\n            #rm(nextSet)\n          } ## if (pval >= alpha)\n        } ## repeat\n        #rm(S)\n      } ## if (length_nbrs >= ord)\n    } ## if(!done)\n    list(G_xy, sepset_xy, num_tests_xy, pMax_xy, done_xy)\n  }\n  \n  # edge test function\n  edge_test <- function(i) {\n    x <- ind[i, 1]\n    y <- ind[i, 2]\n    num_tests_i <- 0\n    G_i <- TRUE\n    pMax_xy <- pMax[x, y]\n    pMax_yx <- pMax[y, x]\n    sepset_xy <- NULL\n    sepset_yx <- NULL\n    done_i <- TRUE\n    \n    # conditioning on neighbors of x\n    res_x <- edge_test_xy(x, y)\n    G_i <- res_x[[1]]\n    sepset_xy <- res_x[[2]]\n    num_tests_i <- num_tests_i + res_x[[3]]\n    pMax_xy <- res_x[[4]]\n    done_i <- done_i & res_x[[5]]\n    \n    if (G_i) {\n      if (ord == 0) {\n        num_tests_i <- num_tests_i + 1\n      } else {\n        # conditioning on neighbors of y\n        res_y <- edge_test_xy(y, x)\n        G_i <- res_y[[1]]\n        sepset_yx <- res_y[[2]]\n        num_tests_i <- num_tests_i + res_y[[3]]\n        pMax_yx <- res_y[[4]]\n        done_i <- done_i & res_y[[5]]\n      }\n    }\n    \n    # cleanup\n    #rm(x)\n    #rm(y)\n    #rm(res_x)\n    #rm(res_y)\n    \n    list(i, G_i, sepset_xy, sepset_yx, num_tests_i, pMax_xy, pMax_yx, done_i)\n  }\n  \n  edge_tests <- function(l) {\n    res <- vector(\"list\",length(l))\n    for (k in 1:length(l)) {\n      res[[k]] <- edge_test(l[[k]])\n    }\n    res\n  }\n  \n  total_mem <- function() {\n    if (Sys.info()[[\"sysname\"]] == \"Linux\") {\n      total <- (as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^MemFree:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Cached:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Inactive:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Buffers:' /proc/meminfo\", intern = TRUE))))/1000\n      return(total)\n    } else if (Sys.info()[[\"sysname\"]] == \"Windows\") {\n      #total <- as.numeric(memory.limit())\n      total <- (as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"wmic OS get FreePhysicalMemory /Value\", intern=TRUE))[3]))/1000\n      return(total)\n    } else { # Mac OS X\n      total <- 4096*(as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages free'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages inactive'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages speculative'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages purgeable'\", intern = TRUE))))/1000000\n      return(total)\n    }\n  }\n  \n  parallel_threshold <- 100\n  if (mem.efficient) {\n    mem_per_test <- 2 #MB\n    tests_per_batch <- as.integer(total_mem() / mem_per_test)\n  }\n  \n  start_total <- proc.time()\n  \n  while (!done && any(G) && ord <= m.max) {\n    n.edgetests[ord1 <- ord+1L] <- 0\n    done <- TRUE\n    ind <- which(G, arr.ind = TRUE)\n    ## For comparison with C++ sort according to first row\n    ind <- ind[order(ind[, 1]), ]\n    ## Consider only unique edge\n    ind <- subset(ind, ind[, 1] < ind[, 2])\n    remainingEdgeTests <- nrow(ind)\n    ## Order-independent version: Compute the adjacency sets for any vertex\n    ## Then don't update when edges are deleted\n    G.l <- split(G, gl(p,p))\n    \n    if (!mem.efficient) {\n      tests_per_batch <- remainingEdgeTests\n    }\n    \n    for (j in seq(1, remainingEdgeTests, by=tests_per_batch)) {\n      l <- min(remainingEdgeTests, j + tests_per_batch - 1)\n      if (l - j + 1 < num_workers) {\n        num_workers <- l - j + 1\n      }\n      res <- NULL\n      if (l - j + 1 < parallel_threshold) {\n        res <- lapply(j:l, edge_test)\n      } else if (Sys.info()[['sysname']] == 'Windows') {\n        res <- do.call(\"c\", clusterApply(workers, clusterSplit(workers, j:l), edge_tests))\n      } else {\n        res <- mclapply(j:l, edge_test, mc.cores=num_workers, mc.set.seed=FALSE, mc.cleanup=TRUE, mc.allow.recursive=FALSE)\n      }\n      \n      # synchronize\n      for (p_obj in res) {\n        i <- p_obj[[1]]\n        x <- ind[i, 1]\n        y <- ind[i, 2]\n        n.edgetests[ord1] <- n.edgetests[ord1] + p_obj[[5]]\n        pMax[x, y] <- p_obj[[6]]\n        pMax[y, x] <- p_obj[[7]]\n        G[x, y] <- G[y, x] <- p_obj[[2]]\n        if (!p_obj[[2]]) {\n          if (!is.null(p_obj[[3]])) sepset[[x]][[y]] <- p_obj[[3]]\n          if (!is.null(p_obj[[4]])) sepset[[y]][[x]] <- p_obj[[4]]\n        }\n        done <- done & p_obj[[8]]\n      }\n    }\n    \n    # increase the nbrs size\n    ord <- ord + 1\n  } ## while()\n  \n  total_t = proc.time()-start_total\n  \n  # write results\n  cat('n=', suffStat[[2]], ',p=', p, '\\n', sep=\"\")\n  cat('Num CI Tests=', n.edgetests, ',Total CI Tests=', sum(unlist(n.edgetests)), ',Total Time=', total_t[3], '\\n', sep=\" \")\n  \n  for (i in 1:(p - 1)) {\n    for (j in 2:p)\n      pMax[i, j] <- pMax[j, i] <- max(pMax[i, j], pMax[j,i])\n  }\n  \n  ## transform matrix to graph object :\n  Gobject <-\n    if (sum(G) == 0) {\n      new(\"graphNEL\", nodes = labels)\n    } else {\n      colnames(G) <- rownames(G) <- labels\n      as(G,\"graphNEL\")\n    }\n  \n  ## final object\n  new(\"pcAlgo\", graph = Gobject, call = cl, n = integer(0),\n      max.ord = as.integer(ord - 1), n.edgetests = n.edgetests,\n      sepset = sepset, pMax = pMax, zMin = matrix(NA, 1, 1))\n  \n}## end{ skeleton }\n\n#########################################################################################\n### pc_stable and pc_parallel\n#########################################################################################\n\n\n### This function is exactly the same as pc() in the pcalg package ###\n#' Estimate the Equivalence Class of a DAG using the PC_stable Algorithm\n#' \n#' @description \n#' Estimate the equivalence class of a directed acyclic graph (DAG) from observational data, using the PC_stable algorithm.\n#' @param suffStat A list of sufficient statistics, containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest A function for testing conditional independence. It is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list, see the argument above. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha significance level (number in (0,1) for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param verbose If TRUE, detailed output is provided.\n#' @param fixedGaps A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.\n#' @param m.max Maximal size of the conditioning sets that are considered in the conditional independence tests.\n#' @param u2pd String specifying the method for dealing with conflicting information when trying to orient edges (see details below).\n#' @param skel.method Character string specifying method; the default, \"stable\" provides an order-independent skeleton, see skeleton.\n#' @param conservative Logical indicating if the conservative PC is used. In this case, only option u2pd = \"relaxed\" is supported. Note that therefore the resulting object might not be extendable to a DAG. See details for more information.\n#' @param maj.rule Logical indicating that the triples shall be checked for ambiguity using a majority rule idea, which is less strict than the conservative PC algorithm. For more information, see details.\n#' @param solve.confl If TRUE, the orientation of the v-structures and the orientation rules work with lists for candidate sets and allow bi-directed edges to resolve conflicting edge orientations. In this case, only option u2pd = relaxed is supported. Note, that therefore the resulting object might not be a CPDAG because bi-directed edges might be present. See details for more information.\n#' @return An object of class \"pcAlgo\" (see pcAlgo) containing an estimate of the equivalence class of the underlying DAG.\n#' @examples\n#' ##########################################\n#' ## Using pc_stable\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' pc_stable(suffStat, indepTest=gaussCItest, p=p, skel.method=\"stable\", alpha=0.01)\n#' @export\npc_stable <- function(suffStat, indepTest, alpha, labels, p,\n                      fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE, m.max = Inf,\n                      u2pd = c(\"relaxed\", \"rand\", \"retry\"),\n                      skel.method = c(\"stable\", \"original\", \"stable.fast\"),\n                      conservative = FALSE, maj.rule = FALSE,\n                      solve.confl = FALSE, verbose = FALSE)\n{ \n  \n  ## Initial Checks\n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  \n  u2pd <- match.arg(u2pd)\n  skel.method <- match.arg(skel.method)\n  if(u2pd != \"relaxed\") {\n    if (conservative || maj.rule)\n      stop(\"Conservative PC and majority rule PC can only be run with 'u2pd = relaxed'\")\n    \n    if (solve.confl)\n      stop(\"Versions of PC using lists for the orientation rules (and possibly bi-directed edges)\\n can only be run with 'u2pd = relaxed'\")\n  }\n  \n  if (conservative && maj.rule) stop(\"Choose either conservative PC or majority rule PC!\")\n  \n  ## Skeleton\n  skel <- skeleton_stable(suffStat, indepTest, alpha, labels=labels, method = skel.method,\n                          fixedGaps=fixedGaps, fixedEdges=fixedEdges,\n                          NAdelete=NAdelete, m.max=m.max, verbose=verbose)\n  skel@call <- cl # so that makes it into result\n  \n  ## Orient edges\n  if (!conservative && !maj.rule) {\n    switch (u2pd,\n            \"rand\" = udag2pdag(skel),\n            \"retry\" = udag2pdagSpecial(skel)$pcObj,\n            \"relaxed\" = udag2pdagRelaxed(skel, verbose=verbose))\n  }\n  else { ## u2pd \"relaxed\" : conservative _or_ maj.rule\n    \n    ## version.unf defined per default\n    ## Tetrad CPC works with version.unf=c(2,1)\n    ## see comment on pc.cons.intern for description of version.unf\n    pc. <- pc.cons.intern(skel, suffStat, indepTest, alpha,\n                          version.unf=c(2,1), maj.rule=maj.rule, verbose=verbose)\n    udag2pdagRelaxed(pc.$sk, verbose=verbose,\n                     unfVect=pc.$unfTripl)\n  }\n}##{pc_stable}\n\n############## Parallel-PC algorithm (based on pc() from pcalg package) #################\n#' Estimate the Equivalence Class of a DAG fast using the PC_parallel Algorithm\n#' \n#' @description \n#' Estimate the equivalence class of a directed acyclic graph (DAG) from observational data, using the PC_parallel algorithm.\n#' @param suffStat A list of sufficient statistics, containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest A function for testing conditional independence. It is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list, see the argument above. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha significance level (number in (0,1) for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param verbose If TRUE, detailed output is provided.\n#' @param fixedGaps A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.\n#' @param m.max Maximal size of the conditioning sets that are considered in the conditional independence tests.\n#' @param u2pd String specifying the method for dealing with conflicting information when trying to orient edges (see details below).\n#' @param mem.efficient Uses less amount of memory at any time point while running the algorithm.\n#' @param skel.method Character string specifying method; the default, \"parallel\" provides an efficient skeleton, see skeleton_parallel.\n#' @param conservative Logical indicating if the conservative PC is used. In this case, only option u2pd = \"relaxed\" is supported. Note that therefore the resulting object might not be extendable to a DAG. See details for more information.\n#' @param maj.rule Logical indicating that the triples shall be checked for ambiguity using a majority rule idea, which is less strict than the conservative PC algorithm. For more information, see details.\n#' @param solve.confl If TRUE, the orientation of the v-structures and the orientation rules work with lists for candidate sets and allow bi-directed edges to resolve conflicting edge orientations. In this case, only option u2pd = relaxed is supported. Note, that therefore the resulting object might not be a CPDAG because bi-directed edges might be present. See details for more information.\n#' @param num.cores Choose numbers of cores CPU to run the algorithm.\n#' @return An object of class \"pcAlgo\" (see pcAlgo) containing an estimate of the equivalence class of the underlying DAG.\n#' @examples\n#' ##########################################\n#' ## Using pc_parallel without mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' pc_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method=\"parallel\", alpha=0.01, num.cores=2)\n#' \n#' ##########################################\n#' ## Using pc_parallel with mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' pc_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method=\"parallel\", \n#' alpha=0.01, num.cores=2, mem.efficient=TRUE)\n#' @export\npc_parallel <- function(suffStat, indepTest, alpha, labels, p,\n                        fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE, m.max = Inf,\n                        u2pd = c(\"relaxed\", \"rand\", \"retry\"),\n                        skel.method = c(\"parallel\"), mem.efficient=FALSE,\n                        conservative = FALSE, maj.rule = FALSE,\n                        solve.confl = FALSE, verbose = FALSE, num.cores = detectCores())\n{\n  \n  ## Initial Checks\n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  \n  u2pd <- match.arg(u2pd)\n  skel.method <- match.arg(skel.method)\n  if(u2pd != \"relaxed\") {\n    if (conservative || maj.rule)\n      stop(\"Conservative PC and majority rule PC can only be run with 'u2pd = relaxed'\")\n    \n    if (solve.confl)\n      stop(\"Versions of PC using lists for the orientation rules (and possibly bi-directed edges)\\n can only be run with 'u2pd = relaxed'\")\n  }\n  \n  if (conservative && maj.rule) stop(\"Choose either conservative PC or majority rule PC!\")\n  \n  # prepare the workers\n  num_workers <- num.cores\n  if (num_workers < 2) {\n    stop(\"The number of cores is insufficient to run parallel-PC\")\n  }\n  workers <- NULL\n  if (Sys.info()[['sysname']] == 'Windows') {\n    workers <- makeCluster(num_workers, type=\"PSOCK\")\n    eval(suffStat)\n    clusterEvalQ(workers, library(pcalg))\n  }\n  \n  ## Skeleton\n  skel <- skeleton_parallel(suffStat, indepTest, alpha, labels=labels, method = skel.method, workers=workers, num_workers=num_workers,\n                            fixedGaps=fixedGaps, fixedEdges=fixedEdges, mem.efficient=mem.efficient,\n                            NAdelete=NAdelete, m.max=m.max, verbose=verbose)\n  skel@call <- cl # so that makes it into result\n  \n  # stop workers\n  if (Sys.info()[['sysname']] == 'Windows') {\n    stopCluster(workers)\n  }\n  \n  ## Orient edges\n  if (!conservative && !maj.rule) {\n    switch (u2pd,\n            \"rand\" = udag2pdag(skel),\n            \"retry\" = udag2pdagSpecial(skel)$pcObj,\n            \"relaxed\" = udag2pdagRelaxed(skel, verbose=verbose))\n  } else { ## u2pd \"relaxed\" : conservative _or_ maj.rule\n    \n    ## version.unf defined per default\n    ## Tetrad CPC works with version.unf=c(2,1)\n    ## see comment on pc.cons.intern for description of version.unf\n    pc. <- pc.cons.intern(skel, suffStat, indepTest, alpha,\n                          version.unf=c(2,1), maj.rule=maj.rule, verbose=verbose)\n    udag2pdagRelaxed(pc.$sk, verbose=verbose,\n                     unfVect=pc.$unfTripl)\n  }\n}##{pc_parallel}\n\n#########################################################################################\n### fci_stable and fci_parallel\n#########################################################################################\n\n### This function is exactly the same as fci() in the pcalg package ###\n#' Estimate a PAG, using the FCI_stable algorithm\n#' \n#' @description \n#' Estimate a Partial Ancestral Graph (PAG) from observational data, using the FCI_stable Algorithm.\n#' @param suffStat Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha Significance level for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param skel.method Character string specifying method; the default, \"stable\" provides an order-independent skeleton, see skeleton.\n#' @param type Character string specifying the version of the FCI algorithm to be used. By default, it is \"normal\", and so the normal FCI algorithm is called. If set to \"anytime\", the 'Anytime FCI' is called and m.max needs to be specified. If set to \"adaptive\", the 'Adaptive Anytime FCI' is called and m.max is not used. For more information, see Details.\n#' @param fixedGaps A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.\n#' @param m.max Maximum size of the conditioning sets that are considered in the conditional independence tests.\n#' @param pdsep.max Maximum size of Possible-D-SEP for which subsets are considered as conditioning sets in the conditional independence tests. If the nodes x and y are adjacent in the graph and the size of Possible-D-SEP(x)\\ x,y is bigger than pdsep.max, the edge is simply left in the graph. Note that if pdsep.max is less than Inf, the final PAG may be a supergraph of the one computed with pdsep.max = Inf, because fewer tests may have been performed in the former.\n#' @param rules Logical vector of length 10 indicating which rules should be used when directing edges. The order of the rules is taken from Zhang (2009).\n#' @param doPdsep If TRUE, Possible-D-SEP is computed for all nodes, and all subsets of Possible-D-SEP are considered as conditioning sets in the conditional independence tests, if not defined otherwise in pdsep.max. If FALSE, Possible-D-SEP is not computed, so that the algorithm simplifies to the Modified PC algorithm of Spirtes, Glymour and Scheines (2000, p.84).\n#' @param biCC If TRUE, only nodes on paths between nodes x and y are considered to be in Possible-D-SEP(x) when testing independence between x and y. Uses biconnected components, biConnComp from RBGL.\n#' @param conservative Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined. For more information, see details.\n#' @param maj.rule Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined using a majority rule idea, which is less strict than the standard conservative. For more information, see details.\n#' @param verbose If true, more detailed output is provided.\n#' @return An object of class fciAlgo (see fciAlgo) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using fci_stable\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' fci_stable(suffStat, indepTest=gaussCItest, p=p, skel.method=\"stable\", alpha=0.01)\n#' @export\nfci_stable <- function(suffStat, indepTest, alpha, labels, p,\n                       skel.method = c(\"stable\", \"original\", \"stable.fast\"),\n                       type = c(\"normal\", \"anytime\", \"adaptive\"),\n                       fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE,\n                       m.max = Inf, pdsep.max = Inf, rules = rep(TRUE, 10),\n                       doPdsep = TRUE, biCC = FALSE, conservative = FALSE,\n                       maj.rule = FALSE, verbose = FALSE)\n{  \n  \n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  \n  ## Check that the type is a valid one\n  type <- match.arg(type)\n  if (type == \"anytime\" && m.max == Inf)\n    stop(\"To use the Anytime FCI you must specify a finite 'm.max'.\")\n  if (type == \"adaptive\" && m.max != Inf)\n    stop(\"To use the Adaptive Anytime FCI you must not specify 'm.max'.\")\n  \n  if (conservative && maj.rule)\n    stop(\"Choose either conservative FCI or majority rule FCI\")\n  \n  cl <- match.call()\n  if (verbose) cat(\"Compute Skeleton\\n================\\n\")\n  \n  skel <- skeleton_stable(suffStat, indepTest, alpha, labels=labels, method = skel.method,\n                          fixedGaps=fixedGaps, fixedEdges=fixedEdges,\n                          NAdelete=NAdelete, m.max=m.max, verbose=verbose)\n  skel@call <- cl # so that makes it into result\n  G <- as(skel@graph, \"matrix\")\n  sepset <- skel@sepset\n  pMax <- skel@pMax\n  n.edgetestsSKEL <- skel@n.edgetests\n  max.ordSKEL <- skel@max.ord\n  allPdsep <- NA\n  tripleList <- NULL\n  \n  if (doPdsep) {\n    if (verbose) cat(\"\\nCompute PDSEP\\n=============\\n\")\n    pc.ci <- pc.cons.intern(skel, suffStat, indepTest,\n                            alpha=alpha, version.unf = c(1,1),\n                            maj.rule=FALSE, verbose=verbose)\n    ## Recompute (sepsets, G, ...):\n    pdsepRes <- pdsep(skel@graph, suffStat, indepTest=indepTest, p=p,\n                      sepset = pc.ci$sk@sepset, alpha=alpha, pMax=pMax,\n                      m.max = if (type == \"adaptive\") max.ordSKEL else m.max,\n                      pdsep.max=pdsep.max, NAdelete=NAdelete,\n                      unfVect = pc.ci$unfTripl, # \"tripleList.pdsep\"\n                      biCC=biCC, verbose=verbose)\n    \n    ## update the graph & sepset :\n    G <- pdsepRes$G\n    sepset <- pdsepRes$sepset\n    pMax <- pdsepRes$pMax\n    allPdsep <- pdsepRes$allPdsep\n    n.edgetestsPD <- pdsepRes$n.edgetests\n    max.ordPD <- pdsepRes$max.ord\n    if (conservative || maj.rule) {\n      if (verbose)\n        cat(\"\\nCheck v-structures conservatively\\n=================================\\n\")\n      tmp.pdsep <- new(\"pcAlgo\", graph = as(G, \"graphNEL\"), call = cl,\n                       n = integer(0), max.ord = as.integer(max.ordSKEL),\n                       n.edgetests = n.edgetestsSKEL, sepset = sepset,\n                       pMax = pMax, zMin = matrix(NA, 1, 1))\n      sk. <- pc.cons.intern(tmp.pdsep, suffStat, indepTest, alpha,\n                            verbose=verbose, version.unf = c(1, 1),\n                            maj.rule=maj.rule)\n      tripleList <- sk.$unfTripl\n      ## update the sepsets\n      sepset <- sk.$sk@sepset\n    }\n  }\n  else {## !doPdsep : \"do not Pdsep\"\n    n.edgetestsPD <- 0\n    max.ordPD <- 0\n    allPdsep <- vector(\"list\", p)\n    if (conservative || maj.rule) {\n      if (verbose)\n        cat(\"\\nCheck v-structures conservatively\\n=================================\\n\")\n      nopdsep <- pc.cons.intern(skel, suffStat, indepTest, alpha,\n                                verbose=verbose, version.unf = c(2, 1),\n                                maj.rule=maj.rule)\n      tripleList <- nopdsep$unfTripl\n      ##update the sepsets\n      sepset <- nopdsep$sk@sepset\n    }\n  }\n  if (verbose)\n    cat(\"\\nDirect egdes:\\n=============\\nUsing rules:\", which(rules),\n        \"\\nCompute collider:\\n\")\n  res <- udag2pag(pag = G, sepset, rules = rules, unfVect = tripleList,\n                  verbose = verbose)\n  colnames(res) <- rownames(res) <- labels\n  new(\"fciAlgo\", amat = res, call = cl, n = integer(0),\n      max.ord = as.integer(max.ordSKEL),\n      max.ordPDSEP = as.integer(max.ordPD),\n      n.edgetests = n.edgetestsSKEL, n.edgetestsPDSEP = n.edgetestsPD,\n      sepset=sepset, pMax=pMax, allPdsep=allPdsep)\n  \n}## {fci_stable}\n\n############## Parallel-FCI algorithm (based on fci() from pcalg package) #################\n#' Estimate a PAG fast, using the FCI_parallel algorithm\n#' \n#' @description \n#' Estimate a Partial Ancestral Graph (PAG) from observational data, using the FCI_parallel Algorithm.\n#' @param suffStat Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha Significance level for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param skel.method Character string specifying method; the default, \"parallel\" provides an efficient skeleton, see skeleton_parallel.\n#' @param mem.efficient Uses less amount of memory at any time point while running the algorithm.\n#' @param type Character string specifying the version of the FCI algorithm to be used. By default, it is \"normal\", and so the normal FCI algorithm is called. If set to \"anytime\", the 'Anytime FCI' is called and m.max needs to be specified. If set to \"adaptive\", the 'Adaptive Anytime FCI' is called and m.max is not used. For more information, see Details.\n#' @param fixedGaps A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.\n#' @param m.max Maximum size of the conditioning sets that are considered in the conditional independence tests.\n#' @param pdsep.max Maximum size of Possible-D-SEP for which subsets are considered as conditioning sets in the conditional independence tests. If the nodes x and y are adjacent in the graph and the size of Possible-D-SEP(x)\\ x,y is bigger than pdsep.max, the edge is simply left in the graph. Note that if pdsep.max is less than Inf, the final PAG may be a supergraph of the one computed with pdsep.max = Inf, because fewer tests may have been performed in the former.\n#' @param rules Logical vector of length 10 indicating which rules should be used when directing edges. The order of the rules is taken from Zhang (2009).\n#' @param doPdsep If TRUE, Possible-D-SEP is computed for all nodes, and all subsets of Possible-D-SEP are considered as conditioning sets in the conditional independence tests, if not defined otherwise in pdsep.max. If FALSE, Possible-D-SEP is not computed, so that the algorithm simplifies to the Modified PC algorithm of Spirtes, Glymour and Scheines (2000, p.84).\n#' @param biCC If TRUE, only nodes on paths between nodes x and y are considered to be in Possible-D-SEP(x) when testing independence between x and y. Uses biconnected components, biConnComp from RBGL.\n#' @param conservative Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined. For more information, see details.\n#' @param maj.rule Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined using a majority rule idea, which is less strict than the standard conservative. For more information, see details.\n#' @param verbose If true, more detailed output is provided.\n#' @param num.cores Choose numbers of cores CPU to run the algorithm\n#' @return An object of class fciAlgo (see fciAlgo) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using fci_parallel without mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' fci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method=\"parallel\", alpha=0.01, num.cores=2)\n#'\n#' ##########################################\n#' ## Using fci_parallel with mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' fci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method=\"parallel\", \n#' alpha=0.01, num.cores=2, mem.efficient=TRUE)\n#' @export\nfci_parallel <- function(suffStat, indepTest, alpha, labels, p,\n                         skel.method = c(\"parallel\"),mem.efficient=FALSE,\n                         type = c(\"normal\", \"anytime\", \"adaptive\"),\n                         fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE,\n                         m.max = Inf, pdsep.max = Inf, rules = rep(TRUE, 10),\n                         doPdsep = TRUE, biCC = FALSE, conservative = FALSE,\n                         maj.rule = FALSE, verbose = FALSE, num.cores = detectCores())\n{\n  \n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  \n  ## Check that the type is a valid one\n  type <- match.arg(type)\n  if (type == \"anytime\" && m.max == Inf)\n    stop(\"To use the Anytime FCI you must specify a finite 'm.max'.\")\n  if (type == \"adaptive\" && m.max != Inf)\n    stop(\"To use the Adaptive Anytime FCI you must not specify 'm.max'.\")\n  \n  if (conservative && maj.rule)\n    stop(\"Choose either conservative FCI or majority rule FCI\")\n  \n  cl <- match.call()\n  if (verbose) cat(\"Compute Skeleton\\n================\\n\")\n  \n  # prepare the workers\n  num_workers <- num.cores\n  if (num_workers < 2) {\n    stop(\"The number of cores is insufficient to run parallel-PC\")\n  }\n  workers <- NULL\n  if (Sys.info()[['sysname']] == 'Windows') {\n    workers <- makeCluster(num_workers, type=\"PSOCK\")\n    eval(suffStat)\n    clusterEvalQ(workers, library(pcalg))\n  }\n  \n  ## Skeleton\n  skel <- skeleton_parallel(suffStat, indepTest, alpha, labels=labels, method = skel.method, workers=workers, num_workers=num_workers,\n                            fixedGaps=fixedGaps, fixedEdges=fixedEdges, mem.efficient=mem.efficient,\n                            NAdelete=NAdelete, m.max=m.max, verbose=verbose)\n  skel@call <- cl # so that makes it into result\n  \n  # stop workers\n  if (Sys.info()[['sysname']] == 'Windows') {\n    stopCluster(workers)\n  }\n  \n  #\n  G <- as(skel@graph, \"matrix\")\n  sepset <- skel@sepset\n  pMax <- skel@pMax\n  n.edgetestsSKEL <- skel@n.edgetests\n  max.ordSKEL <- skel@max.ord\n  allPdsep <- NA\n  tripleList <- NULL\n  \n  if (doPdsep) {\n    if (verbose) cat(\"\\nCompute PDSEP\\n=============\\n\")\n    pc.ci <- pc.cons.intern(skel, suffStat, indepTest,\n                            alpha=alpha, version.unf = c(1,1),\n                            maj.rule=FALSE, verbose=verbose)\n    ## Recompute (sepsets, G, ...):\n    pdsepRes <- pdsep(skel@graph, suffStat, indepTest=indepTest, p=p,\n                      sepset = pc.ci$sk@sepset, alpha=alpha, pMax=pMax,\n                      m.max = if (type == \"adaptive\") max.ordSKEL else m.max,\n                      pdsep.max=pdsep.max, NAdelete=NAdelete,\n                      unfVect = pc.ci$unfTripl, # \"tripleList.pdsep\"\n                      biCC=biCC, verbose=verbose)\n    \n    ## update the graph & sepset :\n    G <- pdsepRes$G\n    sepset <- pdsepRes$sepset\n    pMax <- pdsepRes$pMax\n    allPdsep <- pdsepRes$allPdsep\n    n.edgetestsPD <- pdsepRes$n.edgetests\n    max.ordPD <- pdsepRes$max.ord\n    if (conservative || maj.rule) {\n      if (verbose)\n        cat(\"\\nCheck v-structures conservatively\\n=================================\\n\")\n      tmp.pdsep <- new(\"pcAlgo\", graph = as(G, \"graphNEL\"), call = cl,\n                       n = integer(0), max.ord = as.integer(max.ordSKEL),\n                       n.edgetests = n.edgetestsSKEL, sepset = sepset,\n                       pMax = pMax, zMin = matrix(NA, 1, 1))\n      sk. <- pc.cons.intern(tmp.pdsep, suffStat, indepTest, alpha,\n                            verbose=verbose, version.unf = c(1, 1),\n                            maj.rule=maj.rule)\n      tripleList <- sk.$unfTripl\n      ## update the sepsets\n      sepset <- sk.$sk@sepset\n    }\n  }\n  else {## !doPdsep : \"do not Pdsep\"\n    n.edgetestsPD <- 0\n    max.ordPD <- 0\n    allPdsep <- vector(\"list\", p)\n    if (conservative || maj.rule) {\n      if (verbose)\n        cat(\"\\nCheck v-structures conservatively\\n=================================\\n\")\n      nopdsep <- pc.cons.intern(skel, suffStat, indepTest, alpha,\n                                verbose=verbose, version.unf = c(2, 1),\n                                maj.rule=maj.rule)\n      tripleList <- nopdsep$unfTripl\n      ##update the sepsets\n      sepset <- nopdsep$sk@sepset\n    }\n  }\n  if (verbose)\n    cat(\"\\nDirect egdes:\\n=============\\nUsing rules:\", which(rules),\n        \"\\nCompute collider:\\n\")\n  res <- udag2pag(pag = G, sepset, rules = rules, unfVect = tripleList,\n                  verbose = verbose)\n  colnames(res) <- rownames(res) <- labels\n  new(\"fciAlgo\", amat = res, call = cl, n = integer(0),\n      max.ord = as.integer(max.ordSKEL),\n      max.ordPDSEP = as.integer(max.ordPD),\n      n.edgetests = n.edgetestsSKEL, n.edgetestsPDSEP = n.edgetestsPD,\n      sepset=sepset, pMax=pMax, allPdsep=allPdsep)\n  \n}##{fci_parallel}\n\n#########################################################################################\n### rfci_stable and rfci_parallel\n#########################################################################################\n\n### This function is exactly the same as rfci() in the pcalg package ###\n#' Estimate an RFCI-PAG using the RFCI_stable Algorithm\n#' \n#' @description \n#' Estimate an RFCI-PAG from observational data, using the RFCI-stable algorithm.\n#' @param suffStat Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha significance level (number in (0,1) for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param skel.method Character string specifying method; the default, \"stable\" provides an order-independent skeleton, see skeleton.\n#' @param fixedGaps A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.\n#' @param m.max Maximum size of the conditioning sets that are considered in the conditional independence tests.\n#' @param rules Logical vector of length 10 indicating which rules should be used when directing edges. The order of the rules is taken from Zhang (2009).\n#' @param conservative Logical indicating if the unshielded triples should be checked for ambiguity after the skeleton has been found, similar to the conservative PC algorithm.\n#' @param maj.rule Logical indicating if the unshielded triples should be checked for ambiguity after the skeleton has been found using a majority rule idea, which is less strict than the conservative.\n#' @param verbose If true, more detailed output is provided.\n#' @return An object of class fciAlgo (see fciAlgo) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using rfci_stable\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' rfci_stable(suffStat, indepTest=gaussCItest, p=p, skel.method=\"stable\", alpha=0.01)\n#' @export\nrfci_stable <- function(suffStat, indepTest, alpha, labels, p,\n                        skel.method = c(\"stable\", \"original\", \"stable.fast\"),\n                        fixedGaps = NULL, fixedEdges = NULL,\n                        NAdelete = TRUE, m.max = Inf, rules = rep(TRUE, 10),\n                        conservative = FALSE, maj.rule = FALSE,\n                        verbose = FALSE)\n{\n  \n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  \n  if (conservative && maj.rule)\n    stop(\"Can only choose one of conservative or majority rule RFCI\")\n  if (verbose) cat(\"Compute Skeleton\\n================\\n\")\n  \n  skel <- skeleton_stable(suffStat, indepTest, alpha, labels=labels, method = skel.method,\n                          fixedGaps=fixedGaps, fixedEdges=fixedEdges,\n                          NAdelete=NAdelete, m.max=m.max, verbose=verbose)\n  sk.A <- as(skel@graph, \"matrix\")\n  sepset <- skel@sepset\n  ##the list of all ordered unshielded triples (the graph g does not change it is just a search!)\n  u.t <- find.unsh.triple(sk.A, check=FALSE)\n  \n  ## check and orient v-structures recursively\n  r.v. <- rfci.vStruc(suffStat, indepTest, alpha, sepset, sk.A,\n                      unshTripl = u.t$unshTripl, unshVect = u.t$unshVect,\n                      conservative = (conservative || maj.rule),\n                      version.unf=c(1,1), maj.rule=maj.rule, verbose=verbose)\n  A <- r.v.$amat\n  sepset <- r.v.$sepset\n  \n  ## orient as many edge marks as possible\n  if (verbose)\n    cat(\"\\nDirect egdes:\\n=============\\nUsing rules:\", which(rules), \"\\n\")\n  \n  res <- udag2apag(A, suffStat, indepTest, alpha, sepset,\n                   rules=rules, unfVect = r.v.$unfTripl, verbose=verbose)\n  Amat <- res$graph\n  colnames(Amat) <- rownames(Amat) <- labels\n  new(\"fciAlgo\", amat = Amat, call = cl, n = integer(0),\n      max.ord = as.integer(skel@max.ord), max.ordPDSEP = 0L,\n      n.edgetests = skel@n.edgetests, n.edgetestsPDSEP = 0,\n      sepset = res$sepset, pMax = skel@pMax, allPdsep = vector(\"list\", p))\n  \n}## {rfci_stable}\n\n############## Parallel-RFCI algorithm (based on rfci() from pcalg package) #################\n#' Estimate an RFCI-PAG fast using the RFCI_parallel Algorithm\n#' \n#' @description \n#' Estimate an RFCI-PAG fast from observational data, using the RFCI-parallel algorithm.\n#' @param suffStat Sufficient statistics: List containing all necessary elements for the conditional independence decisions in the function indepTest.\n#' @param indepTest Predefined function for testing conditional independence. The function is internally called as indepTest(x,y,S,suffStat), and tests conditional independence of x and y given S. Here, x and y are variables, and S is a (possibly empty) vector of variables (all variables are denoted by their column numbers in the adjacency matrix). suffStat is a list containing all relevant elements for the conditional independence decisions. The return value of indepTest is the p-value of the test for conditional independence.\n#' @param alpha Significance level for the individual conditional independence tests.\n#' @param labels (optional) character vector of variable (or \"node\") names. Typically preferred to specifying p.\n#' @param p (optional) number of variables (or nodes). May be specified if labels are not, in which case labels is set to 1:p.\n#' @param skel.method Character string specifying method; the default, \"parallel\" provides an efficient skeleton, see skeleton_parallel.\n#' @param mem.efficient Uses less amount of memory at any time point while running the algorithm\n#' @param fixedGaps A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is removed before starting the algorithm. Therefore, this edge is guaranteed to be absent in the resulting graph.\n#' @param fixedEdges A logical matrix of dimension p*p. If entry [i,j] or [j,i] (or both) are TRUE, the edge i-j is never considered for removal. Therefore, this edge is guaranteed to be present in the resulting graph.\n#' @param NAdelete If indepTest returns NA and this option is TRUE, the corresponding edge is deleted. If this option is FALSE, the edge is not deleted.\n#' @param m.max Maximum size of the conditioning sets that are considered in the conditional independence tests.\n#' @param rules Logical vector of length 10 indicating which rules should be used when directing edges. The order of the rules is taken from Zhang (2009).\n#' @param conservative Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined. For more information, see details.\n#' @param maj.rule Logical indicating if the unshielded triples should be checked for ambiguity the second time when v-structures are determined using a majority rule idea, which is less strict than the standard conservative. For more information, see details.\n#' @param verbose If true, more detailed output is provided.\n#' @param num.cores Choose numbers of cores CPU to run the algorithm\n#' @return An object of class fciAlgo (see fciAlgo) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using rfci_parallel without mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' rfci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method=\"parallel\", alpha=0.01, num.cores=2)\n#' \n#' ##########################################\n#' ## Using rfci_parallel with mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel) \n#' data(\"gmG\")\n#' p<-ncol(gmG$x)\n#' suffStat<-list(C=cor(gmG$x),n=nrow(gmG$x))\n#' rfci_parallel(suffStat, indepTest=gaussCItest, p=p, skel.method=\"parallel\", \n#' alpha=0.01, num.cores=2, mem.efficient=TRUE)\n#' @export\nrfci_parallel <- function(suffStat, indepTest, alpha, labels, p,\n                          skel.method = c(\"parallel\"),mem.efficient=FALSE,\n                          fixedGaps = NULL, fixedEdges = NULL,\n                          NAdelete = TRUE, m.max = Inf, rules = rep(TRUE, 10),\n                          conservative = FALSE, maj.rule = FALSE,\n                          verbose = FALSE, num.cores = detectCores())\n{\n  \n  cl <- match.call()\n  if(!missing(p)) stopifnot(is.numeric(p), length(p <- as.integer(p)) == 1, p >= 2)\n  if(missing(labels)) {\n    if(missing(p)) stop(\"need to specify 'labels' or 'p'\")\n    labels <- as.character(seq_len(p))\n  } else { ## use labels ==> p  from it\n    stopifnot(is.character(labels))\n    if(missing(p)) {\n      p <- length(labels)\n    } else if(p != length(labels))\n      stop(\"'p' is not needed when 'labels' is specified, and must match length(labels)\")\n    else\n      message(\"No need to specify 'p', when 'labels' is given\")\n  }\n  seq_p <- seq_len(p)\n  \n  if (conservative && maj.rule)\n    stop(\"Can only choose one of conservative or majority rule RFCI\")\n  if (verbose) cat(\"Compute Skeleton\\n================\\n\")\n  \n  # prepare the workers\n  num_workers <- num.cores\n  if (num_workers < 2) {\n    stop(\"The number of cores is insufficient to run parallel-rfci\")\n  }\n  workers <- NULL\n  if (Sys.info()[['sysname']] == 'Windows') {\n    workers <- makeCluster(num_workers, type=\"PSOCK\")\n    eval(suffStat)\n    clusterEvalQ(workers, library(pcalg))\n  }\n  \n  ## Skeleton\n  skel <- skeleton_parallel(suffStat, indepTest, alpha, labels=labels, method = skel.method, workers=workers, num_workers=num_workers,\n                            fixedGaps=fixedGaps, fixedEdges=fixedEdges, mem.efficient=mem.efficient,\n                            NAdelete=NAdelete, m.max=m.max, verbose=verbose)\n  sk.A <- as(skel@graph, \"matrix\")\n  sepset <- skel@sepset\n  ##the list of all ordered unshielded triples (the graph g does not change it is just a search!)\n  u.t <- find.unsh.triple(sk.A, check=FALSE)\n  \n  ## check and orient v-structures recursively\n  r.v. <- rfci.vStruc(suffStat, indepTest, alpha, sepset, sk.A,\n                      unshTripl = u.t$unshTripl, unshVect = u.t$unshVect,\n                      conservative = (conservative || maj.rule),\n                      version.unf=c(1,1), maj.rule=maj.rule, verbose=verbose)\n  A <- r.v.$amat\n  sepset <- r.v.$sepset\n  \n  # stop workers\n  if (Sys.info()[['sysname']] == 'Windows') {\n    stopCluster(workers)\n  }\n  \n  #\n  \n  ## orient as many edge marks as possible\n  if (verbose)\n    cat(\"\\nDirect egdes:\\n=============\\nUsing rules:\", which(rules), \"\\n\")\n  \n  res <- udag2apag(A, suffStat, indepTest, alpha, sepset,\n                   rules=rules, unfVect = r.v.$unfTripl, verbose=verbose)\n  Amat <- res$graph\n  colnames(Amat) <- rownames(Amat) <- labels\n  new(\"fciAlgo\", amat = Amat, call = cl, n = integer(0),\n      max.ord = as.integer(skel@max.ord), max.ordPDSEP = 0L,\n      n.edgetests = skel@n.edgetests, n.edgetestsPDSEP = 0,\n      sepset = res$sepset, pMax = skel@pMax, allPdsep = vector(\"list\", p))\n  \n}## {rfci_parallel}\n\n#########################################################################################\n### IDA_stable and IDA_parallel\n#########################################################################################\n\n#' Estimate Multiset of Possible Total Causal Effects\n#' \n#' @description \n#' ida_stable() estimates the multiset of possible total causal effects of one variable (x) onto another variable (y) from observational data.\n#' \n#' causalEffect(g,y,x) computes the true causal effect (beta.true) of x on y in g.\n#' @param datacsv read data from .csv file\n#' @param cause the number of integer position of variable x in the covariance matrix.\n#' @param effect the number of integer vector of positions of the target variables y in the covariance matrix.\n#' @param pcmethod Character string specifying method; the default, \"stable\" provides an order-independent skeleton, see skeleton.\n#' @param alpha significance level (number in (0; 1) for the individual conditional independence tests.\n#' @return An object of class fciAlgo (see fciAlgo) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using IDA_stable\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmI\")\n#' datacsv <- cov(gmI$x)\n#' IDA_stable(datacsv,1:2,3:4,\"stable\",0.01) \n#' @export\nIDA_stable <- function(datacsv, cause, effect, pcmethod, alpha){\n  #result=IDA(\"EMT-35.csv\", 1:35, 36:end, \"stable\", 0.01)\n  \n  \n  if(is.character(datacsv)){\n    data=read.csv(datacsv)\n    #data=data[,-1] # if the dataset have the sample names column, otherwise comment this out.\n  } else {\n    data=datacsv #Assume there is no samplenames column and this is a data.frame.\n  }  \t\t\t\t\t\t#To allow both .csv data input or a matrix in R. This will help the IDAbootstrap, as IDA can run on sampling matrices.\n  data=scale(data) #standardise the data\n  #print(data[1:5,])\n  allnames=colnames(data)\n  causenames=allnames[cause]\n  effectnames=allnames[effect]\n  \n  multiset=character(0)\n  result=matrix(nrow=length(effect), ncol=length(cause))\n  suffStat=list(C=cor(data), n=nrow(data))\n  indepTest=gaussCItest\n  \n  start_total_ida <- proc.time()\n  pcFit <- pc_stable(suffStat, indepTest, p=ncol(data), alpha=alpha, skel.method=pcmethod)\n  #pcFit <-pc_parallel(suffStat, indepTest=gaussCItest, p=ncol(data), skel.method=pcmethod, alpha=alpha, num.cores=4)\n  for (l in cause){\n    \n    #Inferring causal effects\n    caef<-idaFast(l,effect,cov(data), pcFit@graph )\n    \n    #min of absolute values.\n    caef1<-matrix(nrow=length(effect),ncol=1)\n    for (k in 1:length(effect)){\n      caefabs<-abs(caef)\n      index<-which(caefabs==min(caefabs[k,]), arr.ind=TRUE)\n      pos<-index[1,2]\n      caef1[k,]<-caef[k,pos]\n    }\n    result[,l]<-caef1\n  }\n  total_t_ida = proc.time()-start_total_ida\n  cat('Total Time ida=', total_t_ida[3], '\\n', sep=\" \")\n  colnames(result)=causenames\n  rownames(result)=effectnames\n  return(result)\t\n}##{IDA_stable}\n\n#' Estimate Multiset of Possible Total Causal Effects fast using the IDA_parallel Algorithm\n#' \n#' @description \n#' ida_parallel() fast estimates the multiset of possible total causal effects of one variable (x) onto another variable (y) from observational data.\n#' \n#' causalEffect(g,y,x) computes the true causal effect (beta.true) of x on y in g.\n#' @param datacsv read data from .csv file\n#' @param cause the number of integer position of variable x in the covariance matrix.\n#' @param effect the number of integer vector of positions of the target variables y in the covariance matrix.\n#' @param pcmethod Character string specifying method; the default, \"parallel\" provides an efficient skeleton, see skeleton_parallel.\n#' @param alpha significance level (number in (0; 1) for the individual conditional independence tests.\n#' @param num.cores Choose numbers of cores CPU to run the algorithm\n#' @param mem.efficient Uses less amount of memory at any time point while running the algorithm\n#' @return An object of class fciAlgo (see fciAlgo) containing the estimated graph (in the form of an adjacency matrix with various possible edge marks), the conditioning sets that lead to edge removals (sepset) and several other parameters.\n#' @examples\n#' ##########################################\n#' ## Using IDA_parallel without mem.efficeient\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmI\")\n#' datacsv <- cov(gmI$x)\n#' IDA_parallel(datacsv,1:2,3:4,\"parallel\",0.01, 2)\n#' \n#' ##########################################\n#' ## Using IDA_parallel with mem.efficeient\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' data(\"gmI\")\n#' datacsv <- cov(gmI$x)\n#' IDA_parallel(datacsv,1:2,3:4,\"parallel\",0.01, 2, TRUE)\n#' @export\nIDA_parallel <- function(datacsv, cause, effect, pcmethod, alpha, num.cores, mem.efficient=FALSE){\n  #result=IDA(\"EMT-35.csv\", 1:35, 36:end, \"parallel\",0.01, 4, TRUE)\n  \n  if(is.character(datacsv)){\n    data=read.csv(datacsv)\n    #data=data[,-1] # if the dataset have the sample names column, otherwise comment this out.\n  } else {\n    data=datacsv #Assume there is no samplenames column and this is a data.frame.\n  }  \t\t\t\t\t\t#To allow both .csv data input or a matrix in R. This will help the IDAbootstrap, as IDA can run on sampling matrices.\n  data=scale(data) #standardise the data\n  #print(data[1:5,])\n  allnames=colnames(data)\n  causenames=allnames[cause]\n  effectnames=allnames[effect]\n  \n  multiset=character(0)\n  result=matrix(nrow=length(effect), ncol=length(cause))\n  suffStat=list(C=cor(data), n=nrow(data))\n  indepTest=gaussCItest\n  \n  start_total_ida <- proc.time()\n  #pcFit <- pc_stable(suffStat, indepTest, p=ncol(data), alpha=alpha, skel.method=pcmethod)\n  #pcFit <-pc_parallel(suffStat, indepTest=gaussCItest, p=ncol(data), skel.method=pcmethod, alpha=alpha, num.cores=num.cores, mem.efficient=mem.efficient)\n  pcFit <-pc_parallel(suffStat, indepTest, p=ncol(data), skel.method=pcmethod, alpha=alpha, num.cores=num.cores, mem.efficient=mem.efficient)\n  for (l in cause){\n    \n    #Inferring causal effects\n    caef<-idaFast(l,effect,cov(data), pcFit@graph )\n    \n    #min of absolute values.\n    caef1<-matrix(nrow=length(effect),ncol=1)\n    for (k in 1:length(effect)){\n      caefabs<-abs(caef)\n      index<-which(caefabs==min(caefabs[k,]), arr.ind=TRUE)\n      pos<-index[1,2]\n      caef1[k,]<-caef[k,pos]\n    }\n    result[,l]<-caef1\n  }\n  total_t_ida = proc.time()-start_total_ida\n  cat('Total Time ida=', total_t_ida[3], '\\n', sep=\" \")\n  colnames(result)=causenames\n  rownames(result)=effectnames\n  return(result)\t\n}##{IDA_parallel}\n\n\n#########################################################################################\n### pcSelect_stable and pcSelect_parallel\n#########################################################################################\n\n### This function is exactly the same as pcSelect() in the pcalg package ###\n#' Estimate subgraph around a response variable\n#' \n#' @description \n#' The goal is feature selection: If you have a response variable y and a data matrix dm, we want\n#' to know which variables are \"strongly influential\" on y. The type of influence is the same as in\n#' the PC-Algorithm, i.e., y and x (a column of dm) are associated if they are correlated even when\n#' conditioning on any subset of the remaining columns in dm. Therefore, only very strong relations\n#' will be found and the result is typically a subset of other feature selection techniques. Note that\n#' there are also robust correlation methods available which render this method robust.\n#' @param y Response vector.\n#' @param dm Data matrix (rows: samples/observations, columns: variables); nrow(dm) == length(y).\n#' @param alpha Significance level of individual partial correlation tests.\n#' @param corMethod \"standard\" or \"Qn\" for standard or robust correlation estimation\n#' @param method Character string specifying method; the default, \"stable\" provides an Order-independent version. \n#' @param verbose Logical or in \\{0,1,2\\};\n#' \n#'        FALSE, 0: No output,\n#'        \n#'        TRUE, 1: Little output,\n#'        \n#'        2: Detailed output.\n#'        \n#'        Note that such output makes the function very much slower.\n#' @param directed Logical; should the output graph be directed?\n#' @return \n#' G    A logical vector indicating which column of dm is associated with y.\n#' \n#' zMin   The minimal z-values when testing partial correlations between y and each column of dm. The larger the number, the more consistent is the edge with the data.\n#' @examples\n#' ##########################################\n#' ## Using pcSelect_stable\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' p <- 10\n#' set.seed(101)\n#' myDAG <- randomDAG(p, prob = 0.2)\n#' n <- 1000\n#' d.mat <- rmvDAG(n, myDAG, errDist = \"normal\")\n#' pcSelect_stable(d.mat[,10],d.mat[,-10], alpha=0.05)\n#' @export\npcSelect_stable <- function(y,dm, alpha, corMethod = \"standard\",method = \"stable\", verbose = FALSE, directed=FALSE)\n{\n  ## Purpose: Find columns in dm, that have nonzero parcor with y given\n  ## any other set of columns in dm\n  ## ----------------------------------------------------------------------\n  ## Arguments:\n  ## - y: Response Vector (length(y)=nrow(dm))\n  ## - dm: Data matrix (rows: samples, cols: nodes)\n  ## - alpha: Significance level of individual partial correlation tests\n  ## - corMethod: \"standard\" or \"Qn\" for standard or robust correlation\n  ##              estimation\n  ## - verbose: 0-no output, 1-small output, 2-details\n  ## ----------------------------------------------------------------------\n  ## Value: List\n  ## - G: boolean vector with connected nodes\n  ## - zMin: Minimal z values\n  ## ----------------------------------------------------------------------\n  ## Author: Markus Kalisch, Date: 27.4.07\n  \n  stopifnot((n <- nrow(dm)) >= 1,\n            (p <- ncol(dm)) >= 1)\n  vNms <- colnames(dm)\n  cl <- match.call()\n  \n  zMin <- c(0,rep.int(Inf,p))\n  C <- mcor(cbind(y,dm), method = corMethod)\n  cutoff <- qnorm(1 - alpha/2)\n  n.edgetests <- numeric(1)# final length = max { ord}\n  ## G := complete graph :\n  G <- matrix(c(FALSE,rep.int(TRUE,p)),nrow = p+1,ncol = 1)\n\n  seq_p <- 1:(p+1)\n  \n  done <- FALSE\n  ord <- 0\n  \n  start_total <- proc.time()\n  \n  while (!done && any(G)) {\n    n.edgetests[ord+1] <- 0\n    done <- TRUE\n    ind <- which(G)\n    remainingEdgeTests <- length(ind)\n    if(verbose>=1)\n      cat(\"Order=\",ord,\"; remaining edges:\",remainingEdgeTests,\"\\n\", sep='')\n\n    if(method == \"stable\") {\n      ## Order-independent version: Compute the adjacency sets for any vertex\n      ## Then don't update when edges are deleted\n      G.l <- split(G, gl(p+1,1))\n    }\n    \n    for (i in 1:remainingEdgeTests) {\n      if(verbose && i%%100==0) cat(\"|i=\",i,\"|iMax=\",nrow(ind),\"\\n\")\n      y <- 1\n      x <- ind[i]\n      \n      if (G[x]) {\n        nbrsBool <- if(method == \"stable\") as.logical(G.l) else G \n        nbrsBool[x] <- FALSE\n        nbrs <- seq_p[nbrsBool]\n        ## neighbors of y without itself and x\n        length_nbrs <- length(nbrs)\n        \n        if (length_nbrs >= ord) {\n          if (length_nbrs > ord) done <- FALSE\n          S <- seq(length = ord)\n          \n          ## now includes special cases (ord == 0) or (length_nbrs == 1):\n          repeat {\n            n.edgetests[ord+1] <- n.edgetests[ord+1]+1\n            #cat('n.edgetests[ord+1]=',n.edgetests[ord+1],\"\\n\")\n            z <- zStat(x,y, nbrs[S], C,n)\n            #cat('x=',x,'y=',y,\"\\n\")\n            if(abs(z)<zMin[x]) zMin[x] <- abs(z)\n            #cat('zMin_x=',zMin[x],\"\\n\")\n            if (verbose >= 2)\n              cat(paste(\"x:\",vNms[x-1],\"y:\",(ytmp <- round((p+1)/2)),\"S:\"),\n                  c(ytmp,vNms)[nbrs[S]],paste(\"z:\",z,\"\\n\"))\n            if (abs(z) <= cutoff) {\n              G[x] <- FALSE\n              break\n            }\n            else {\n              nextSet <- getNextSet(length_nbrs, ord, S)\n              if(nextSet$wasLast){\n                break\n              }\n              S <- nextSet$nextSet\n            }\n          } ## {repeat}\n        }\n      } ## end if( G )\n    } ## end for(i ..)\n    ord <- ord+1\n  } ## end while\n  \n  total_t = proc.time()-start_total\n  \n  \n  # write results\n  cat('Num CI Tests=', n.edgetests, ',Total CI Tests=', sum(unlist(n.edgetests)), ',Total Time=', total_t[3], '\\n', sep=\" \")\n  \n  Gres <- G[-1]\n  names(Gres) <- vNms\n  list(G = Gres, zMin = zMin[-1])\n}## pcSelect_stable\n\n############## Parallel-pcSelect algorithm (based on pcSelect() from pcalg package) #################\n#' Estimate subgraph around a response variable,using pcSelect_parallel to get fast.\n#' \n#' @description \n#' The goal is feature selection: If you have a response variable y and a data matrix dm, we want\n#' to know which variables are \"strongly influential\" on y. The type of influence is the same as in\n#' the PC-Algorithm, i.e., y and x (a column of dm) are associated if they are correlated even when\n#' conditioning on any subset of the remaining columns in dm. Therefore, only very strong relations\n#' will be found and the result is typically a subset of other feature selection techniques. Note that\n#' there are also robust correlation methods available which render this method robust.\n#' @param y Response vector.\n#' @param dm Data matrix (rows: samples/observations, columns: variables); nrow(dm) == length(y).\n#' @param method Character string specifying method; the default, \"parallel\" provides an efficient method.\n#' @param alpha Significance level of individual partial correlation tests.\n#' @param corMethod \"standard\" or \"Qn\" for standard or robust correlation estimation\n#' @param verbose Logical or in \\{0,1,2\\};\n#' \n#'        FALSE, 0: No output,\n#'        \n#'        TRUE, 1: Little output,\n#'        \n#'        2: Detailed output.\n#'        \n#'        Note that such output makes the function very much slower.\n#' @param directed Logical; should the output graph be directed?\n#' @param num_workers Choose numbers of cores CPU as numbers of workers to run the algorithm\n#' @param mem.efficient Uses less amount of memory at any time point while running the algorithm\n#' @return \n#' G    A logical vector indicating which column of dm is associated with y.\n#' \n#' zMin   The minimal z-values when testing partial correlations between y and each column of dm. The larger the number, the more consistent is the edge with the data.\n#' @examples\n#' ##########################################\n#' ## Using pcSelect_parallel without mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel)\n#' p <- 10\n#' set.seed(101)\n#' myDAG <- randomDAG(p, prob = 0.2)\n#' n <- 1000\n#' d.mat <- rmvDAG(n, myDAG, errDist = \"normal\")\n#' pcSelect_parallel(d.mat[,10],d.mat[,-10], alpha=0.05,num_workers=2)\n#' \n#' ##########################################\n#' ## Using pcSelelct_parallel with mem.efficeient\n#' ##########################################\n#' library(pcalg)\n#' library(parallel) \n#' p <- 10\n#' set.seed(101)\n#' myDAG <- randomDAG(p, prob = 0.2)\n#' n <- 1000\n#' d.mat <- rmvDAG(n, myDAG, errDist = \"normal\")\n#' pcSelect_parallel(d.mat[,10],d.mat[,-10], alpha=0.05,mem.efficient=TRUE,num_workers=2)\n#' @export\npcSelect_parallel <- function(y,dm,method = c(\"parallel\"),mem.efficient=FALSE,num_workers, alpha, corMethod = \"standard\", verbose = FALSE, directed=FALSE)\n{\n  ## Purpose: Find columns in dm, that have nonzero parcor with y given\n  ## any other set of columns in dm\n  ## ----------------------------------------------------------------------\n  ## Arguments:\n  ## - y: Response Vector (length(y)=nrow(dm))\n  ## - dm: Data matrix (rows: samples, cols: nodes)\n  ## - alpha: Significance level of individual partial correlation tests\n  ## - corMethod: \"standard\" or \"Qn\" for standard or robust correlation\n  ##              estimation\n  ## - verbose: 0-no output, 1-small output, 2-details\n  ## ----------------------------------------------------------------------\n  ## Value: List\n  ## - G: boolean vector with connected nodes\n  ## - zMin: Minimal z values\n  ## ----------------------------------------------------------------------\n  ## Author: Shu Hu, Date: 05.05.15\n  stopifnot((n <- nrow(dm)) >= 1,\n            (p <- ncol(dm)) >= 1)\n  vNms <- colnames(dm)\n  cl <- match.call()\n  \n  zMin <- c(0,rep.int(Inf,p))\n  C <- mcor(cbind(y,dm), method = corMethod)\n  cutoff <- qnorm(1 - alpha/2)\n  n.edgetests <- numeric(1)# final length = max { ord}\n  ## G := complete graph :\n  G <- c(FALSE,rep.int(TRUE,p))\n  seq_p <- 1:(p+1)\n  \n  done <- FALSE\n  ord <- 0\n  \n  # prepare the workers\n  if (num_workers < 2) {\n    stop(\"The number of cores is insufficient to run parallel-PC\")\n  }\n  workers <- NULL\n  if (Sys.info()[['sysname']] == 'Windows') {\n    workers <- makeCluster(num_workers, type=\"PSOCK\")\n    eval(dm)\n    clusterEvalQ(workers, library(pcalg))\n  }\n  \n  # edge test function, conditioning on x's neighbours\n  edge_test_xy <- function(x,y){\n    G_x <- TRUE\n    G_y <- TRUE\n    num_tests_xy <- 0\n    zMin_x <- zMin[x]\n    \n    done_xy <- TRUE\n    if (G_x){\n      #nbrsBool <- G.l[[x]]\n      nbrsBool <-as.logical(G.l)\n      nbrsBool[x] <- FALSE\n      nbrs <- seq_p[nbrsBool]\n      ## neighbors of y without itself and x\n      length_nbrs <- length(nbrs)\n      if (length_nbrs >= ord){\n        if (length_nbrs > ord) done_xy <- FALSE\n        S <- seq(length = ord)\n        \n        ## now includes special cases (ord == 0) or (length_nbrs == 1):\n        repeat{\n          #cat(\"num_tests_xy=\",num_tests_xy,\"\\n\")\n          num_tests_xy <- num_tests_xy + 1\n          z <- zStat(x,y, nbrs[S], C,n)\n          #cat('x=',x,'y=',y,\"\\n\")\n          if(abs(z)<zMin_x) zMin_x <- abs(z)\n          #cat('zMin_x=',zMin_x,\"\\n\")\n          if (verbose >= 2)\n            cat(paste(\"x:\",vNms[x-1],\"y:\",(ytmp <- round((p+1)/2)),\"S:\"),\n                c(ytmp,vNms)[nbrs[S]],paste(\"z:\",z,\"\\n\"))\n          if (abs(z) <= cutoff) {\n            G_x <- FALSE\n            #cat('do1',\"\\n\")\n            break\n          }\n          else {\n            nextSet <- getNextSet(length_nbrs, ord, S)\n            if(nextSet$wasLast){\n              #cat('do2',\"\\n\")\n              break\n            }\n            S <- nextSet$nextSet\n            #cat('do3',\"\\n\")\n          }\n          \n        } ## {repeat}\n        \n        \n      } ## if (length_nbrs >= ord)\n    } ## if(!done)\n    list(G_x, num_tests_xy, zMin_x, done_xy)\n  }\n  \n  # edge test function\n  edge_test <- function(i) {\n    y <- 1\n    x <- ind[i]\n    num_tests_i <- 0\n    G_i <- TRUE\n    zMin_x <- zMin[x]\n    #zMin_y <- zMin[y]\n    done_i <- TRUE\n    \n    # conditioning on neighbors of x\n    res_x <- edge_test_xy(x, y)\n    G_i <- res_x[[1]]\n    #cat(\"G_i=\",G_i,\"\\n\")\n    #sepset_xy <- res_x[[2]]\n    num_tests_i <- num_tests_i + res_x[[2]]\n    # num_tests_i <- num_tests_i + 1\n    #cat(\"num_tests_i_1=\",num_tests_i,\"\\n\")\n    zMin_x <- res_x[[3]]\n    done_i <- done_i & res_x[[4]]\n    \n    \n    \n    if (G_i) {\n      if (ord == 0) {\n        #         num_tests_i <- num_tests_i+1\n      }else {\n        #         # conditioning on neighbors of y\n        res_y <- edge_test_xy(y, x)\n        #         G_i <- res_y[[1]]\n        #         num_tests_i <- num_tests_i + res_y[[2]]\n        #         num_tests_i <- num_tests_i + 1\n        #        zMin_y <- res_y[[3]]\n        done_i <- done_i & res_y[[4]]\n      }\n    }\n    # rm(x)\n    # rm(y)\n    # rm(res_x)\n    # rm(res_y)\n    \n    list(i, G_i, num_tests_i, zMin_x, done_i)\n    \n  }\n  \n  edge_tests <- function(l) {\n    res <- vector(\"list\",length(l))\n    for (k in 1:length(l)) {\n      res[[k]] <- edge_test(l[[k]])\n    }\n    res\n  }\n  \n  total_mem <- function() {\n    if (Sys.info()[[\"sysname\"]] == \"Linux\") {\n      total <- (as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^MemFree:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Cached:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Inactive:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Buffers:' /proc/meminfo\", intern = TRUE))))/1000\n      return(total)\n    } else if (Sys.info()[[\"sysname\"]] == \"Windows\") {\n      #total <- as.numeric(memory.limit())\n      total <- (as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"wmic OS get FreePhysicalMemory /Value\", intern=TRUE))[3]))/1000\n      return(total)\n    } else { # Mac OS X\n      total <- 4096*(as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages free'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages inactive'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages speculative'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages purgeable'\", intern = TRUE))))/1000000\n      return(total)\n    }\n  }\n  \n  parallel_threshold <- 100\n  if (mem.efficient) {\n    mem_per_test <- 2 #MB\n    tests_per_batch <- as.integer(total_mem() / mem_per_test)\n  }\n  \n  start_total <- proc.time()\n  \n  while (!done && any(G)){\n    n.edgetests[ord+1] <- 0\n    done <- TRUE\n    ind <- which(G)\n    #     ## Consider only unique edge\n    #     ind <- subset(ind, ind[1] < ind[2])\n    remainingEdgeTests <- length(ind)\n    if(verbose>=1)\n      cat(\"Order=\",ord,\"; remaining edges:\",remainingEdgeTests,\"\\n\", sep='')\n    G.l <- split(G, gl(p+1,1))\n    \n    if (!mem.efficient) {\n      tests_per_batch <- remainingEdgeTests\n    }\n    \n    for (j in seq(1, remainingEdgeTests, by=tests_per_batch)){\n      l <- min(remainingEdgeTests, j + tests_per_batch - 1)\n      #cat(\"l - j + 1=\",l - j + 1,\"\\n\")\n      #cat(\"parallel_threshold=\",parallel_threshold,\"\\n\")\n      if (l - j + 1 < num_workers) {\n        num_workers <- l - j + 1        \n      }\n      res <- NULL\n      if (l - j + 1 < parallel_threshold) {\n        res <- lapply(j:l, edge_test)\n      } else if (Sys.info()[['sysname']] == 'Windows') {\n        res <- do.call(\"c\", clusterApply(workers, clusterSplit(workers, j:l), edge_tests))\n        #cat('res=',res,\"\\n\")\n      } else {\n        res <- mclapply(j:l, edge_test, mc.cores=num_workers, mc.set.seed=FALSE, mc.cleanup=TRUE, mc.allow.recursive=FALSE)\n      }\n      \n      \n      # synchronize\n      for (p_obj in res) {\n        i <- p_obj[[1]]\n        #x <- ind[i, 1]\n        #y <- ind[i, 2]\n        y <- 1\n        x <- ind[i]\n        n.edgetests[ord+1] <- n.edgetests[ord+1] + p_obj[[3]]\n        #cat('p_obj[[3]]=',p_obj[[3]],\"\\n\")\n        #cat('n.edgetests[ord+1]=',n.edgetests[ord+1],\"\\n\")\n        #pMax[x, y] <- p_obj[[6]]\n        zMin[x] <- p_obj[[4]]\n        #zMin[y] <- p_obj[[5]]\n        #G[x, y] <- G[y, x] <- p_obj[[2]]\n        G[x] <-p_obj[[2]]\n        done <- done & p_obj[[5]]\n      }\n      \n    }\n    \n    # increase the nbrs size\n    ord <- ord + 1\n    \n  }## end while\n  \n  total_t = proc.time()-start_total\n  \n  \n  # write results\n  cat('Num CI Tests=', n.edgetests, ',Total CI Tests=', sum(unlist(n.edgetests)), ',Total Time=', total_t[3], '\\n', sep=\" \")\n  \n  Gres <- G[-1]\n  names(Gres) <- vNms\n  list(G = Gres, zMin = zMin[-1])\n  \n}## pcSelect_parallel\n\n\n################################################################\n\n##Different indepTest methods\n\n################################################################\n\n################################################################\n#linear regression test\n#' linear regression test\n#' \n#' @description \n#' linear regression is an approach for modeling the relationship between a scalar dependent variable y and one or more explanatory variables (or independent variable) denoted X\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using myCItest1\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' myCItest1(1,2,3,suffStat)\n#' @export\nmyCItest1=function(x,y,S, suffStat){\n  \n  if(length(S)==0){\n    x.=suffStat[,x]\n    y.=suffStat[,y]\n  }\n  else{\n    rxy <- resid(lm.fit(y= suffStat[,c(x,y)], x= cbind(1, suffStat[,S])))\n    x. <- rxy[,1]; y. <- rxy[,2]\n  }\n  cor.test(x., y.)$p.value\n  \n}\n##############################################################\n#gaussCItest\n#' gaussCItest test\n#' \n#' @description \n#' The gaussCItest() function, using zStat() to test for (conditional) independence between gaussian\n#' random variables, with an interface that can easily be used in skeleton, pc and fci\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using myCItest2\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' myCItest2(1,2,3,suffStat)\n#' @export\nmyCItest2=function(x,y,S, suffStat){\n  \n  #x, y, and S are passed from the main algorithm. We need to specify the paramater to \n  #satify the pre-defined tests\n  \n  gaussCItest(x,y,S,suffStat=list(C=cor(suffStat), n=nrow(suffStat)))\n  \n}\n###############################################################\n#gaussCItest=bnlearn::zf\n#' The asymptotic normal test (zf)\n#' \n#' @description \n#' a transformation of the linear correlation with asymptotic normal distribution.\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using zf\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' zf(1,2,3,suffStat)\n#' @export\nzf=function(x,y,S, suffStat){\n  \n  #x, y, and S are passed from the main algorithm. We need to specify the paramater to \n  #satify the pre-defined tests\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStatis the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"zf\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n\n###############################################################\n#' The Monte Carlo permutation test (mc-zf)\n#' \n#' @description \n#' a transformation of the linear correlation with asymptotic normal distribution.\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using mczf\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' mczf(1,2,3,suffStat)\n#' @export\nmczf=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"mc-zf\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n##############################################################\n#' The sequential Monte Carlo permutation test (smc-zf)\n#' \n#' @description \n#' a transformation of the linear correlation with asymptotic normal distribution.\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using smczf\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' smczf(1,2,3,suffStat)\n#' @export\nsmczf=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"smc-zf\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n################################################################\n\n################################################################\n\n#mutual information: bnlearn::mi-g\n#' The asymptotic Chi-square test (mi-g)\n#' \n#' @description \n#' an information-theoretic distance measure. Again it is proportional to the log-likelihood ratio (they differ by a 2n factor)\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using mig\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' mig(1,2,3,suffStat)\n#' @export\n\nmig=function(x,y,S, suffStat){\n  \n  #x, y, and S are passed from the main algorithm. We need to specify the paramater to \n  #satify the pre-defined tests\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStatis the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"mi-g\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n\n################################################################\n#mutual information Monte Carlo: bnlearn::mc-mi-g\n#' The Monte Carlo permutation test (mc-mi-g)\n#' \n#' @description \n#' an information-theoretic distance measure. Again it is proportional to the log-likelihood ratio (they differ by a 2n factor)\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using mcmig\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' mcmig(1,2,3,suffStat)\n#' @export\nmcmig=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"mc-mi-g\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n\n#mutual information Sequential Monte Carlo: bnlearn:: smc-mi-g\n################################################################\n#' The sequential Monte Carlo permutation test (smc-mi-g)\n#' \n#' @description \n#' an information-theoretic distance measure. Again it is proportional to the log-likelihood ratio (they differ by a 2n factor)\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using smcmig\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' smcmig(1,2,3,suffStat)\n#' @export\nsmcmig=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"smc-mi-g\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n\n#Shrinkage estimator for mutual information\n################################################################\n#' Shrinkage estimator for the mutual information (mi-g-sh)\n#' \n#' @description \n#' an improved asymptotic Chi-square test based on the James-Stein estimator for the mutual information.\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using migsh\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' migsh(1,2,3,suffStat)\n#' @export\nmigsh=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"mi-g-sh\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n#Pearson's chi-square\n################################################################\n#' The exact Student's t test (cor2)\n#' \n#' @description \n#' linear correlation: Pearson's linear correlation.\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using cor2\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' cor2(1,2,3,suffStat)\n#' @export\ncor2=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"cor\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n################################################################\n#Monte Carlo Pearson's chi-square\n#' The Monte Carlo permutation test (mc-cor)\n#' \n#' @description \n#' linear correlation: Pearson's linear correlation.\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using mccor\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' mccor(1,2,3,suffStat)\n#' @export\nmccor=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"mc-cor\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}\n################################################################\n#Sequential Monte Carlo Pearson's chi-square\n#' The sequential Monte Carlo permutation test (smc-cor)\n#' \n#' @description \n#' linear correlation: Pearson's linear correlation.\n#' @param x,y,S It is tested, whether x and y are conditionally independent given the subset S of\n#'        the remaining nodes. x, y, S all are integers, corresponding to variable or node\n#'        numbers.\n#' @param suffStat is the dataset.\n#' @return the p-value of the test.\n#' @examples\n#' ##########################################\n#' ## Using smccor\n#' ##########################################\n#' library(bnlearn)\n#' library(pcalg)\n#' library(parallel)\n#' library(Rgraphviz)\n#' data(\"gmG\")\n#' suffStat<-gmG$x\n#' smccor(1,2,3,suffStat)\n#' @export\nsmccor=function(x,y,S, suffStat){\n  \n  if(!is.data.frame(suffStat)) suffStat=data.frame(suffStat)#suffStat is the dataset\n  Namex=colnames(suffStat)[x]\n  Namey=colnames(suffStat)[y]\n  Namez=colnames(suffStat)[S]\n  \n  test=bnlearn::ci.test(x=Namex, y=Namey, z=Namez, data=suffStat, test=\"smc-cor\")\n  pval=test$p.value\n  cat(\"x=\",x,\" y=\",y,\" S=\", S, \"pvalue=\", pval, \"\\n\")\n  pval\n  \n  \n}",
    "created" : 1430291870985.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1336581220",
    "id" : "CF2A4F65",
    "lastKnownWriteTime" : 1433985920,
    "path" : "C:/Users/huysy011/Desktop/Thuc_paper/PackagePCCIwithPCSelect/PackagePCCIwithPCSelect/ParallelPC/R/ParallelPC.R",
    "project_path" : "R/ParallelPC.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}