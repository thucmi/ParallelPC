{
    "contents" : "#########################################################################################\n### Author: Shu Hu\n### Date: 1st May 2015\n### Please cite the following paper when using the code\n### Paper: A fast PC algorithm for high dimensional causal discovery with multi-core PCs\n#########################################################################################\n\nlibrary(pcalg)\nlibrary(parallel)\n\npcSelect_parallel <- function(y,dm,method = c(\"parallel\"),mem.efficient=FALSE,num_workers, alpha, corMethod = \"standard\", verbose = FALSE, directed=FALSE)\n{\n  ## Purpose: Find columns in dm, that have nonzero parcor with y given\n  ## any other set of columns in dm\n  ## ----------------------------------------------------------------------\n  ## Arguments:\n  ## - y: Response Vector (length(y)=nrow(dm))\n  ## - dm: Data matrix (rows: samples, cols: nodes)\n  ## - alpha: Significance level of individual partial correlation tests\n  ## - corMethod: \"standard\" or \"Qn\" for standard or robust correlation\n  ##              estimation\n  ## - verbose: 0-no output, 1-small output, 2-details\n  ## ----------------------------------------------------------------------\n  ## Value: List\n  ## - G: boolean vector with connected nodes\n  ## - zMin: Minimal z values\n  ## ----------------------------------------------------------------------\n  ## Author: Shu Hu, Date: 05.05.15\n  stopifnot((n <- nrow(dm)) >= 1,\n            (p <- ncol(dm)) >= 1)\n  vNms <- colnames(dm)\n  cl <- match.call()\n  \n  zMin <- c(0,rep.int(Inf,p))\n  C <- mcor(cbind(y,dm), method = corMethod)\n  cutoff <- qnorm(1 - alpha/2)\n  n.edgetests <- numeric(1)# final length = max { ord}\n  ## G := complete graph :\n  G <- c(FALSE,rep.int(TRUE,p))\n  seq_p <- 1:(p+1)\n  \n  done <- FALSE\n  ord <- 0\n  \n  # prepare the workers\n  if (num_workers < 2) {\n    stop(\"The number of cores is insufficient to run parallel-PC\")\n  }\n  workers <- NULL\n  if (Sys.info()[['sysname']] == 'Windows') {\n    workers <- makeCluster(num_workers, type=\"PSOCK\")\n    eval(dm)\n    clusterEvalQ(workers, library(pcalg))\n  }\n  \n  # edge test function, conditioning on x's neighbours\n  edge_test_xy <- function(x,y){\n    G_x <- TRUE\n    G_y <- TRUE\n    num_tests_xy <- 0\n    zMin_x <- zMin[x]\n    \n    done_xy <- TRUE\n    if (G_x){\n      #nbrsBool <- G.l[[x]]\n      nbrsBool <-as.logical(G.l)\n      nbrsBool[x] <- FALSE\n      nbrs <- seq_p[nbrsBool]\n      ## neighbors of y without itself and x\n      length_nbrs <- length(nbrs)\n      if (length_nbrs >= ord){\n        if (length_nbrs > ord) done_xy <- FALSE\n        S <- seq(length = ord)\n        \n        ## now includes special cases (ord == 0) or (length_nbrs == 1):\n        repeat{\n          #cat(\"num_tests_xy=\",num_tests_xy,\"\\n\")\n          num_tests_xy <- num_tests_xy + 1\n          z <- zStat(x,y, nbrs[S], C,n)\n          #cat('x=',x,'y=',y,\"\\n\")\n          if(abs(z)<zMin_x) zMin_x <- abs(z)\n          #cat('zMin_x=',zMin_x,\"\\n\")\n          if (verbose >= 2)\n            cat(paste(\"x:\",vNms[x-1],\"y:\",(ytmp <- round((p+1)/2)),\"S:\"),\n                c(ytmp,vNms)[nbrs[S]],paste(\"z:\",z,\"\\n\"))\n          if (abs(z) <= cutoff) {\n            G_x <- FALSE\n            #cat('do1',\"\\n\")\n            break\n          }\n          else {\n            nextSet <- getNextSet(length_nbrs, ord, S)\n            if(nextSet$wasLast){\n              #cat('do2',\"\\n\")\n              break\n            }\n            S <- nextSet$nextSet\n            #cat('do3',\"\\n\")\n          }\n          \n        } ## {repeat}\n        \n        \n      } ## if (length_nbrs >= ord)\n    } ## if(!done)\n    list(G_x, num_tests_xy, zMin_x, done_xy)\n  }\n  \n  # edge test function\n  edge_test <- function(i) {\n    y <- 1\n    x <- ind[i]\n    num_tests_i <- 0\n    G_i <- TRUE\n    zMin_x <- zMin[x]\n    #zMin_y <- zMin[y]\n    done_i <- TRUE\n    \n    # conditioning on neighbors of x\n    res_x <- edge_test_xy(x, y)\n    G_i <- res_x[[1]]\n    #cat(\"G_i=\",G_i,\"\\n\")\n    #sepset_xy <- res_x[[2]]\n    num_tests_i <- num_tests_i + res_x[[2]]\n   # num_tests_i <- num_tests_i + 1\n    #cat(\"num_tests_i_1=\",num_tests_i,\"\\n\")\n    zMin_x <- res_x[[3]]\n    done_i <- done_i & res_x[[4]]\n    \n    \n    \n     if (G_i) {\n       if (ord == 0) {\n#         num_tests_i <- num_tests_i+1\n       }else {\n#         # conditioning on neighbors of y\n         res_y <- edge_test_xy(y, x)\n#         G_i <- res_y[[1]]\n#         num_tests_i <- num_tests_i + res_y[[2]]\n#         num_tests_i <- num_tests_i + 1\n#        zMin_y <- res_y[[3]]\n         done_i <- done_i & res_y[[4]]\n       }\n     }\n# rm(x)\n# rm(y)\n# rm(res_x)\n# rm(res_y)\n    \n    list(i, G_i, num_tests_i, zMin_x, done_i)\n    \n  }\n  \n  edge_tests <- function(l) {\n    res <- vector(\"list\",length(l))\n    for (k in 1:length(l)) {\n      res[[k]] <- edge_test(l[[k]])\n    }\n    res\n  }\n  \n  total_mem <- function() {\n    if (Sys.info()[[\"sysname\"]] == \"Linux\") {\n      total <- (as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^MemFree:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Cached:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Inactive:' /proc/meminfo\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"egrep '^Buffers:' /proc/meminfo\", intern = TRUE))))/1000\n      return(total)\n    } else if (Sys.info()[[\"sysname\"]] == \"Windows\") {\n      #total <- as.numeric(memory.limit())\n      total <- (as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"wmic OS get FreePhysicalMemory /Value\", intern=TRUE))[3]))/1000\n      return(total)\n    } else { # Mac OS X\n      total <- 4096*(as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages free'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages inactive'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages speculative'\", intern = TRUE))) + as.numeric(gsub(\"[^0-9]*([0-9]*)\", \"\\\\1\", system(\"vm_stat | grep 'Pages purgeable'\", intern = TRUE))))/1000000\n      return(total)\n    }\n  }\n  \n  parallel_threshold <- 100\n  if (mem.efficient) {\n    mem_per_test <- 2 #MB\n    tests_per_batch <- as.integer(total_mem() / mem_per_test)\n  }\n  \n  start_total <- proc.time()\n  \n  while (!done && any(G)){\n    n.edgetests[ord+1] <- 0\n    done <- TRUE\n    ind <- which(G)\n#     ## Consider only unique edge\n#     ind <- subset(ind, ind[1] < ind[2])\n    remainingEdgeTests <- length(ind)\n    if(verbose>=1)\n      cat(\"Order=\",ord,\"; remaining edges:\",remainingEdgeTests,\"\\n\", sep='')\n    G.l <- split(G, gl(p+1,1))\n    \n    if (!mem.efficient) {\n      tests_per_batch <- remainingEdgeTests\n    }\n    \n    for (j in seq(1, remainingEdgeTests, by=tests_per_batch)){\n      l <- min(remainingEdgeTests, j + tests_per_batch - 1)\n      #cat(\"l - j + 1=\",l - j + 1,\"\\n\")\n      #cat(\"parallel_threshold=\",parallel_threshold,\"\\n\")\n      if (l - j + 1 < num_workers) {\n        num_workers <- l - j + 1        \n      }\n      res <- NULL\n      if (l - j + 1 < parallel_threshold) {\n        res <- lapply(j:l, edge_test)\n      } else if (Sys.info()[['sysname']] == 'Windows') {\n        res <- do.call(\"c\", clusterApply(workers, clusterSplit(workers, j:l), edge_tests))\n        #cat('res=',res,\"\\n\")\n      } else {\n        res <- mclapply(j:l, edge_test, mc.cores=num_workers, mc.set.seed=FALSE, mc.cleanup=TRUE, mc.allow.recursive=FALSE)\n      }\n      \n      \n      # synchronize\n      for (p_obj in res) {\n        i <- p_obj[[1]]\n        #x <- ind[i, 1]\n        #y <- ind[i, 2]\n        y <- 1\n        x <- ind[i]\n        n.edgetests[ord+1] <- n.edgetests[ord+1] + p_obj[[3]]\n        #cat('p_obj[[3]]=',p_obj[[3]],\"\\n\")\n        #cat('n.edgetests[ord+1]=',n.edgetests[ord+1],\"\\n\")\n        #pMax[x, y] <- p_obj[[6]]\n        zMin[x] <- p_obj[[4]]\n        #zMin[y] <- p_obj[[5]]\n        #G[x, y] <- G[y, x] <- p_obj[[2]]\n        G[x] <-p_obj[[2]]\n        done <- done & p_obj[[5]]\n      }\n      \n    }\n    \n    # increase the nbrs size\n    ord <- ord + 1\n    \n  }## end while\n  \n  total_t = proc.time()-start_total\n  \n  \n  # write results\n  cat('Num CI Tests=', n.edgetests, ',Total CI Tests=', sum(unlist(n.edgetests)), ',Total Time=', total_t[3], '\\n', sep=\" \")\n  \n  Gres <- G[-1]\n  names(Gres) <- vNms\n  list(G = Gres, zMin = zMin[-1])\n  \n}## pcSelect_parallel\n\npcSelect_stable <- function(y,dm, alpha, corMethod = \"standard\",method = \"stable\", verbose = FALSE, directed=FALSE)\n{\n  ## Purpose: Find columns in dm, that have nonzero parcor with y given\n  ## any other set of columns in dm\n  ## ----------------------------------------------------------------------\n  ## Arguments:\n  ## - y: Response Vector (length(y)=nrow(dm))\n  ## - dm: Data matrix (rows: samples, cols: nodes)\n  ## - alpha: Significance level of individual partial correlation tests\n  ## - corMethod: \"standard\" or \"Qn\" for standard or robust correlation\n  ##              estimation\n  ## - verbose: 0-no output, 1-small output, 2-details\n  ## ----------------------------------------------------------------------\n  ## Value: List\n  ## - G: boolean vector with connected nodes\n  ## - zMin: Minimal z values\n  ## ----------------------------------------------------------------------\n  ## Author: Markus Kalisch, Date: 27.4.07\n  \n  stopifnot((n <- nrow(dm)) >= 1,\n            (p <- ncol(dm)) >= 1)\n  vNms <- colnames(dm)\n  cl <- match.call()\n  \n  zMin <- c(0,rep.int(Inf,p))\n  C <- mcor(cbind(y,dm), method = corMethod)\n  cutoff <- qnorm(1 - alpha/2)\n  n.edgetests <- numeric(1)# final length = max { ord}\n  ## G := complete graph :\n  #G <- c(FALSE,rep.int(TRUE,p))\n  G <- matrix(c(FALSE,rep.int(TRUE,p)),nrow = p+1,ncol = 1)\n  #G <- as.matrix(G)\n  #G<-as.list(G)\n  #View(G)\n  #View(G1)\n  seq_p <- 1:(p+1)\n  #seq_p <- seq_len(p)\n  \n  done <- FALSE\n  ord <- 0\n  \n  start_total <- proc.time()\n  \n  while (!done && any(G)) {\n    n.edgetests[ord+1] <- 0\n    done <- TRUE\n    ind <- which(G)\n    remainingEdgeTests <- length(ind)\n    if(verbose>=1)\n      cat(\"Order=\",ord,\"; remaining edges:\",remainingEdgeTests,\"\\n\", sep='')\n    ##hushu\n    if(method == \"stable\") {\n      #View(G)\n      #cat(typeof(G))\n      ## Order-independent version: Compute the adjacency sets for any vertex\n      ## Then don't update when edges are deleted\n      G.l <- split(G, gl(p+1,1))\n      #View(G.l)\n      #G<-as.factor(G)\n      #G.l <- split(G,G$factor)\n    }\n    #hushu\n    for (i in 1:remainingEdgeTests) {\n      if(verbose && i%%100==0) cat(\"|i=\",i,\"|iMax=\",nrow(ind),\"\\n\")\n      y <- 1\n      x <- ind[i]\n      \n      if (G[x]) {\n        nbrsBool <- if(method == \"stable\") as.logical(G.l) else G \n        #nbrsBool <- G\n        #View(G.l[[x]])\n        #View(G.l[x])\n        #View(G)\n        nbrsBool[x] <- FALSE\n        #View(seq_p[nbrsBool])\n        #nbrs <- seq_p[nbrsBool[[i]]]\n        nbrs <- seq_p[nbrsBool]\n        ## neighbors of y without itself and x\n        length_nbrs <- length(nbrs)\n        \n        if (length_nbrs >= ord) {\n          if (length_nbrs > ord) done <- FALSE\n          S <- seq(length = ord)\n          \n          ## now includes special cases (ord == 0) or (length_nbrs == 1):\n          repeat {\n            n.edgetests[ord+1] <- n.edgetests[ord+1]+1\n            #cat('n.edgetests[ord+1]=',n.edgetests[ord+1],\"\\n\")\n            z <- zStat(x,y, nbrs[S], C,n)\n            #cat('x=',x,'y=',y,\"\\n\")\n            if(abs(z)<zMin[x]) zMin[x] <- abs(z)\n            #cat('zMin_x=',zMin[x],\"\\n\")\n            if (verbose >= 2)\n              cat(paste(\"x:\",vNms[x-1],\"y:\",(ytmp <- round((p+1)/2)),\"S:\"),\n                  c(ytmp,vNms)[nbrs[S]],paste(\"z:\",z,\"\\n\"))\n            if (abs(z) <= cutoff) {\n              G[x] <- FALSE\n              break\n            }\n            else {\n              nextSet <- getNextSet(length_nbrs, ord, S)\n              if(nextSet$wasLast){\n                break\n            }\n              S <- nextSet$nextSet\n            }\n          } ## {repeat}\n        }\n      } ## end if( G )\n    } ## end for(i ..)\n    ord <- ord+1\n  } ## end while\n  \n  total_t = proc.time()-start_total\n  \n  \n  # write results\n  cat('Num CI Tests=', n.edgetests, ',Total CI Tests=', sum(unlist(n.edgetests)), ',Total Time=', total_t[3], '\\n', sep=\" \")\n  \n  Gres <- G[-1]\n  names(Gres) <- vNms\n  list(G = Gres, zMin = zMin[-1])\n}## pcSelect_stable\n\n\npcSelect_orignal <- function(y,dm, alpha, corMethod = \"standard\",method = \"stable\", verbose = FALSE, directed=FALSE)\n{\n  ## Purpose: Find columns in dm, that have nonzero parcor with y given\n  ## any other set of columns in dm\n  ## ----------------------------------------------------------------------\n  ## Arguments:\n  ## - y: Response Vector (length(y)=nrow(dm))\n  ## - dm: Data matrix (rows: samples, cols: nodes)\n  ## - alpha: Significance level of individual partial correlation tests\n  ## - corMethod: \"standard\" or \"Qn\" for standard or robust correlation\n  ##              estimation\n  ## - verbose: 0-no output, 1-small output, 2-details\n  ## ----------------------------------------------------------------------\n  ## Value: List\n  ## - G: boolean vector with connected nodes\n  ## - zMin: Minimal z values\n  ## ----------------------------------------------------------------------\n  ## Author: Markus Kalisch, Date: 27.4.07\n  \n  stopifnot((n <- nrow(dm)) >= 1,\n            (p <- ncol(dm)) >= 1)\n  vNms <- colnames(dm)\n  cl <- match.call()\n  \n  zMin <- c(0,rep.int(Inf,p))\n  C <- mcor(cbind(y,dm), method = corMethod)\n  cutoff <- qnorm(1 - alpha/2)\n  n.edgetests <- numeric(1)# final length = max { ord}\n  ## G := complete graph :\n  G <- c(FALSE,rep.int(TRUE,p))\n  #G <- matrix(c(FALSE,rep.int(TRUE,p)),nrow = p+1,ncol = 1)\n  #G <- matrix(c(FALSE,rep.int(TRUE,p)),nrow = p+1,ncol = 1)\n  #G <- as.matrix(G)\n  #G<-as.list(G)\n  #View(G)\n  #View(G1)\n  seq_p <- 1:(p+1)\n  \n  done <- FALSE\n  ord <- 0\n  \n  start_total <- proc.time()\n  \n  while (!done && any(G)) {\n    n.edgetests[ord+1] <- 0\n    done <- TRUE\n    ind <- which(G)\n    remainingEdgeTests <- length(ind)\n    if(verbose>=1)\n      cat(\"Order=\",ord,\"; remaining edges:\",remainingEdgeTests,\"\\n\", sep='')\n    ##hushu\n#     if(method == \"stable\") {\n#       #View(G)\n#       ## Order-independent version: Compute the adjacency sets for any vertex\n#       ## Then don't update when edges are deleted\n#       G.l <- split(G, gl(p+1,1))\n#       #G<-as.factor(G)\n#       #G.l <- split(G,G$factor)\n#       View(G.l)\n#     }\n    #hushu\n    for (i in 1:remainingEdgeTests) {\n      if(verbose && i%%100==0) cat(\"|i=\",i,\"|iMax=\",nrow(ind),\"\\n\")\n      y <- 1\n      x <- ind[i]\n      \n      if (G[x]) {\n        #nbrsBool <- if(method == \"stable\") G.l[[x]] else G\n        #View(G)\n        nbrsBool <- G\n        nbrsBool[x] <- FALSE\n        #View(seq_p[nbrsBool])\n        nbrs <- seq_p[nbrsBool]\n        ## neighbors of y without itself and x\n        length_nbrs <- length(nbrs)\n        \n        if (length_nbrs >= ord) {\n          if (length_nbrs > ord) done <- FALSE\n          S <- seq(length = ord)\n          \n          ## now includes special cases (ord == 0) or (length_nbrs == 1):\n          repeat {\n            n.edgetests[ord+1] <- n.edgetests[ord+1]+1\n            #cat('n.edgetests[ord+1]=',n.edgetests[ord+1],\"\\n\")\n            z <- zStat(x,y, nbrs[S], C,n)\n            #cat('x=',x,'y=',y,\"\\n\")\n            if(abs(z)<zMin[x]) zMin[x] <- abs(z)\n            #cat('zMin_x=',zMin[x],\"\\n\")\n            if (verbose >= 2)\n              cat(paste(\"x:\",vNms[x-1],\"y:\",(ytmp <- round((p+1)/2)),\"S:\"),\n                  c(ytmp,vNms)[nbrs[S]],paste(\"z:\",z,\"\\n\"))\n            if (abs(z) <= cutoff) {\n              G[x] <- FALSE\n              break\n            }\n            else {\n              nextSet <- getNextSet(length_nbrs, ord, S)\n              if(nextSet$wasLast){\n                break\n              }\n              S <- nextSet$nextSet\n            }\n          } ## {repeat}\n        }\n      } ## end if( G )\n    } ## end for(i ..)\n    ord <- ord+1\n  } ## end while\n  \n  total_t = proc.time()-start_total\n  \n  \n  # write results\n  cat('Num CI Tests=', n.edgetests, ',Total CI Tests=', sum(unlist(n.edgetests)), ',Total Time=', total_t[3], '\\n', sep=\" \")\n  \n  Gres <- G[-1]\n  names(Gres) <- vNms\n  list(G = Gres, zMin = zMin[-1])\n}## pcSelect_orignal",
    "created" : 1432617297562.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2965186640",
    "id" : "AA0A4827",
    "lastKnownWriteTime" : 1433823706,
    "path" : "C:/Users/Administrator/Desktop/Thuc_paper/Codes/parallel-PCSelect.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}